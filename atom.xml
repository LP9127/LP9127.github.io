<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liupei.link/"/>
  <updated>2020-12-15T16:27:03.774Z</updated>
  <id>https://liupei.link/</id>
  
  <author>
    <name>liupei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>问题分析与解决</title>
    <link href="https://liupei.link/2020/11/25/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>https://liupei.link/2020/11/25/问题解决与分析/</id>
    <published>2020-11-25T15:40:24.000Z</published>
    <updated>2020-12-15T16:27:03.774Z</updated>
    
    <content type="html"><![CDATA[<p>在日常生活中遇到问题的时候，一般都是凭经验去思考如何解决这个问题；但是往往因为经验的不足，或者因为环境的变化，以前的经验早已不适用，导致问题没有得到解决；那有没有一个方法能指导我们去分析&amp;解决问题，而不是仅凭经验的判断呢？</p><h3 id="一、问题分析的3个原则"><a href="#一、问题分析的3个原则" class="headerlink" title="一、问题分析的3个原则"></a>一、问题分析的3个原则</h3><h4 id="1-基于事实分析"><a href="#1-基于事实分析" class="headerlink" title="1.基于事实分析"></a>1.基于事实分析</h4><p>基于事实分析可以弥补经验的不足，增加方案的可信度</p><h4 id="2-结构化分析"><a href="#2-结构化分析" class="headerlink" title="2.结构化分析"></a>2.结构化分析</h4><p>遵从MECE法则（相互独立，完全穷尽）：对问题做到不重叠，不遗漏的分析，能够把握问题的核心，成为有效解决方案</p><h4 id="3-以假设为导向"><a href="#3-以假设为导向" class="headerlink" title="3.以假设为导向"></a>3.以假设为导向</h4><p>大胆假设，小心求证，找到真相产生的条件</p><h3 id="二、问题分析的4个步骤"><a href="#二、问题分析的4个步骤" class="headerlink" title="二、问题分析的4个步骤"></a>二、问题分析的4个步骤</h3><p>拆解和定位问题：80%</p><p>解决方案：20%</p><h4 id="1-明确和理解问题"><a href="#1-明确和理解问题" class="headerlink" title="1.明确和理解问题"></a>1.明确和理解问题</h4><p>遇到问题：先搞清楚问题的本质是什么</p><p>如果明确需求：</p><ul><li>找出需求方关心的点</li><li>明确目标（不同的目标，不同的解决方案）</li><li>明确解决问题需要的资源</li></ul><h4 id="2-拆分和定位问题"><a href="#2-拆分和定位问题" class="headerlink" title="2.拆分和定位问题"></a>2.拆分和定位问题</h4><ul><li><p>复杂问题拆分到最小问题（纵向拆分原则）</p><p>复杂问题：掺杂了多个维度和变量的问题，不可直接解决，因此要先进行拆解</p><p>最小问题：最本质，最细微的待解决问题</p><p>把很小的目标融会贯通，用更高层的思维要求自己，找到问题的价值链，找到内部逻辑，确定核心最小问题</p></li><li><p>MECE法则（横向拆分原则）</p><p>搭建逻辑结构：想问题的时候有一条线，不是漫无目的（核心问题和起始问题；问题原因；问题后果；画树；补充）</p></li><li><p>价值链思维（商业问题的最佳拆解模式）</p><p>抓住问题本质并用极简的形式描述出来</p></li><li><p>逻辑树（呈现形式）</p><p>图形化思考</p></li><li><p>假设验证（定位问题）</p><p>假设验证：能够明确目标（证实，证伪），省时省力</p></li></ul><h4 id="3-提出解决方案"><a href="#3-提出解决方案" class="headerlink" title="3.提出解决方案"></a>3.提出解决方案</h4><ul><li>假设验证：MECE原则</li><li>验证结果：果汁稀释法</li></ul><h4 id="4-总结问题"><a href="#4-总结问题" class="headerlink" title="4.总结问题"></a>4.总结问题</h4><ul><li>别人觉得是对的，比自己认为是对的更重要</li><li>从结论不断分析，直到那个不可辩驳的事实</li><li>每一个层级都要控制要点的数目，要突出重点</li></ul><h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><h4 id="1-对信息进行3级分类"><a href="#1-对信息进行3级分类" class="headerlink" title="1.对信息进行3级分类"></a>1.对信息进行3级分类</h4><p>不完备或者逻辑不正确，可能是假信息</p><p>总结问题的时候，先说<strong>结论</strong>，再说<strong>理由</strong>（论据），最后列举出<strong>事实</strong>（案例，支撑论据，证明结论）</p><h4 id="2-结构化分析的方法和工具"><a href="#2-结构化分析的方法和工具" class="headerlink" title="2.结构化分析的方法和工具"></a>2.结构化分析的方法和工具</h4><ul><li>最小问题</li><li>价值链思维</li><li>逻辑树</li><li>MECE原则</li></ul><p>MECE的5种分法：二分法、过程法、要素法、公式法、矩阵法</p><h4 id="3-常见思维工具模型"><a href="#3-常见思维工具模型" class="headerlink" title="3.常见思维工具模型"></a>3.常见思维工具模型</h4><p>SWOT</p><p>ADDT</p><p>4P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常生活中遇到问题的时候，一般都是凭经验去思考如何解决这个问题；但是往往因为经验的不足，或者因为环境的变化，以前的经验早已不适用，导致问题没有得到解决；那有没有一个方法能指导我们去分析&amp;amp;解决问题，而不是仅凭经验的判断呢？&lt;/p&gt;
&lt;h3 id=&quot;一、问题分析的3个
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://liupei.link/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20201125</title>
    <link href="https://liupei.link/2020/11/25/20201125/"/>
    <id>https://liupei.link/2020/11/25/20201125/</id>
    <published>2020-11-25T15:36:16.000Z</published>
    <updated>2020-11-25T15:39:23.560Z</updated>
    
    <content type="html"><![CDATA[<p>管住嘴更容易呢？还是迈开腿更容易？</p><p>嗯～还是尽量管住嘴吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;管住嘴更容易呢？还是迈开腿更容易？&lt;/p&gt;
&lt;p&gt;嗯～还是尽量管住嘴吧&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="思" scheme="https://liupei.link/tags/%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>20201123</title>
    <link href="https://liupei.link/2020/11/23/20201123/"/>
    <id>https://liupei.link/2020/11/23/20201123/</id>
    <published>2020-11-23T15:36:17.000Z</published>
    <updated>2020-11-23T15:43:29.427Z</updated>
    
    <content type="html"><![CDATA[<p>夜雨</p><p>[唐]白居易</p><p>我有所念人，隔在远远乡。</p><p>我有所感事，结在深深肠。</p><p>乡远去不得，无日不瞻望。</p><p>肠深解不得，无夕不思量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;夜雨&lt;/p&gt;
&lt;p&gt;[唐]白居易&lt;/p&gt;
&lt;p&gt;我有所念人，隔在远远乡。&lt;/p&gt;
&lt;p&gt;我有所感事，结在深深肠。&lt;/p&gt;
&lt;p&gt;乡远去不得，无日不瞻望。&lt;/p&gt;
&lt;p&gt;肠深解不得，无夕不思量。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="思" scheme="https://liupei.link/tags/%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>k8s容器健康检查</title>
    <link href="https://liupei.link/2020/08/16/k8s%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>https://liupei.link/2020/08/16/k8s容器健康检查/</id>
    <published>2020-08-16T06:43:53.000Z</published>
    <updated>2020-11-23T15:10:07.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="k8s容器检查探针"><a href="#k8s容器检查探针" class="headerlink" title="k8s容器检查探针"></a>k8s容器检查探针</h3><p>当容器部署在k8s中的时候，k8s通过 liveness probe 和 readiness probe来监测容器的健康状况，其中liveness probe 和 readiness probe是由容器所在node上的kubelet定期执行的，那关于iveness probe  和 readiness probe分别有以下几个问题</p><p><strong>liveness probe</strong></p><p>1.如何理解”存活“状态？</p><p>2.容器配置了存活探针和没有配置存活探针有什么区别？</p><p>3.存活探针有哪几种探测方式？分别是如何配置和如何工作的？</p><p>4.如果存活探针探测失败会采取什么策略？</p><p><strong>readiness probe</strong></p><p>1.如何理解”就绪“状态？</p><p>2.容器配置了就绪探针和没有配置就绪探针有什么区别？</p><p>3.就绪探针有哪几种探测方式？分别是如何配置和如何工作的？</p><p>4.如果就绪探针探测失败会采取什么策略？</p><h3 id="liveness-probe"><a href="#liveness-probe" class="headerlink" title="liveness probe"></a>liveness probe</h3><h5 id="1-如何理解容器的“存活”状态？"><a href="#1-如何理解容器的“存活”状态？" class="headerlink" title="1.如何理解容器的“存活”状态？"></a>1.如何理解容器的“存活”状态？</h5><p>容器存活，指的是容器可以在虚拟机上运行，但是这并不意味着容器已经可以提供服务。</p><h5 id="2-什么样的容器需要配置存活探针？容器配置了存活探针和没有配置存活探针有什么区别？"><a href="#2-什么样的容器需要配置存活探针？容器配置了存活探针和没有配置存活探针有什么区别？" class="headerlink" title="2.什么样的容器需要配置存活探针？容器配置了存活探针和没有配置存活探针有什么区别？"></a>2.什么样的容器需要配置存活探针？容器配置了存活探针和没有配置存活探针有什么区别？</h5><p>如果容器中的进程能够在遇到问题或者不健康的情况下自行崩溃，那么就需要配置一个存活探针，来让k8s监测容器的健康状况；而不是以docker返回的容器的状态作为依据</p><h5 id="3-存活探针有哪几种探测方式？分别是如何工作的？"><a href="#3-存活探针有哪几种探测方式？分别是如何工作的？" class="headerlink" title="3.存活探针有哪几种探测方式？分别是如何工作的？"></a>3.存活探针有哪几种探测方式？分别是如何工作的？</h5><p>容器所在节点上的kubelet调用handler（处理程序）对容器进行探测</p><p>handler有以下三种类型:</p><ul><li>ExecAction:在容器内执行指定命令，如果命令退出时的返回码为0，则表示探测成功；反之表示探测失败</li><li>TCPSocketAction:对容器IP地址上的指定端口进行TCP检查，如果端口打开，则表示探测成功；反之表示探测失败</li><li>HTTPGetAction:对容器IP地址上指定端口和路径执行HTTP Get请求，如果响应的状态码大于等于200，且小于400，则表示探测成功；反之表示探测失败</li></ul><p>如何配置3种类型的探针</p><ul><li>ExecAction</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness</span><br><span class="line">  name: test-liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span><br><span class="line">    livenessProbe: //存活探针</span><br><span class="line">      exec: //探针类型为ExecAction</span><br><span class="line">        command: //指定命令</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5 //容器启动后5s后开始执行命令进行探测</span><br><span class="line">      periodSeconds: 5  //此后每隔5s探测一次</span><br></pre></td></tr></table></figure><ul><li>TCPSocketAction</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: probe-tcp</span><br><span class="line">  namespace: coocla</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    livenessProbe: //存活探针</span><br><span class="line">      initialDelaySeconds: 5 //容器启动后5s后开始执行命令进行探测</span><br><span class="line">      timeoutSeconds: 1 //此后每隔1s探测一次</span><br><span class="line">      tcpSocket: //探针类型为TCPSocketAction</span><br><span class="line">        port: 80 //探测的端口</span><br></pre></td></tr></table></figure><ul><li>HTTPGetAction</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: probe-http</span><br><span class="line">  namespace: coocla</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    livenessProbe: //存活探针</span><br><span class="line">      httpGet: //探针类型为HTTPGetAction</span><br><span class="line">        path: //探测的路径</span><br><span class="line">        port: 80  //探测的端口</span><br><span class="line">        host: www.baidu.com //探测的url</span><br><span class="line">        scheme: HTTPS //协议是https</span><br><span class="line">      initialDelaySeconds: 5 //容器启动后5s后开始执行命令进行探测</span><br><span class="line">      timeoutSeconds: 1 //此后每隔5s探测一次</span><br></pre></td></tr></table></figure><p>每次探测都会得到以下3种结果：</p><ul><li>success:容器通过了探测</li><li>failure:容器未通过探测</li><li>unknown:诊断失败，不会对容器采取任何措施</li></ul><h5 id="4-如果存活探针探测失败会采取什么策略？"><a href="#4-如果存活探针探测失败会采取什么策略？" class="headerlink" title="4.如果存活探针探测失败会采取什么策略？"></a>4.如果存活探针探测失败会采取什么策略？</h5><p>如果存活探针探测失败，则表示kubelet会将该容器kill掉，然后再根据容器的RestarPolicy进行下一步操作</p><p>每一个容器都可以重启策略（RestarPolicy），RestarPolicy有三种选项可以选择：</p><ul><li>Always（默认值）：只要container退出就重新启动</li><li>Onfailure：当container非正常退出后重新启动</li><li>never：从不重启container</li></ul><h3 id="readiness-probe"><a href="#readiness-probe" class="headerlink" title="readiness probe"></a>readiness probe</h3><h5 id="1-如何理解容器的“就绪”状态？"><a href="#1-如何理解容器的“就绪”状态？" class="headerlink" title="1.如何理解容器的“就绪”状态？"></a>1.如何理解容器的“就绪”状态？</h5><p>容器就绪表示container是否以及处于可接受service的请求了</p><h5 id="2-什么样的容器需要配置存活探针？容器配置了就绪探针和没有配置就绪探针有什么区别？"><a href="#2-什么样的容器需要配置存活探针？容器配置了就绪探针和没有配置就绪探针有什么区别？" class="headerlink" title="2.什么样的容器需要配置存活探针？容器配置了就绪探针和没有配置就绪探针有什么区别？"></a>2.什么样的容器需要配置存活探针？容器配置了就绪探针和没有配置就绪探针有什么区别？</h5><p>就绪态探针的存在意味着 Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据，所以如果你的容器需要加载大规模的数据、配置文件或者在启动期间执行迁移操作，可以添加一个就绪探针。</p><h5 id="3-存活探针有哪几种探测方式？分别是如何工作的？-1"><a href="#3-存活探针有哪几种探测方式？分别是如何工作的？-1" class="headerlink" title="3.存活探针有哪几种探测方式？分别是如何工作的？"></a>3.存活探针有哪几种探测方式？分别是如何工作的？</h5><p>同“存活”探针</p><h5 id="4-如果存活探针探测失败会采取什么策略？-1"><a href="#4-如果存活探针探测失败会采取什么策略？-1" class="headerlink" title="4.如果存活探针探测失败会采取什么策略？"></a>4.如果存活探针探测失败会采取什么策略？</h5><p>如果ReadinessProbe失败，endpoints controller将会从service所匹配到的endpoint列表中移除关于这个container的IP地址，所以如果配置了就绪探针，对于Service匹配到的 endpoints有哪些，是ReadinessProbe决定的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;k8s容器检查探针&quot;&gt;&lt;a href=&quot;#k8s容器检查探针&quot; class=&quot;headerlink&quot; title=&quot;k8s容器检查探针&quot;&gt;&lt;/a&gt;k8s容器检查探针&lt;/h3&gt;&lt;p&gt;当容器部署在k8s中的时候，k8s通过 liveness probe 和 readi
      
    
    </summary>
    
      <category term="k8s" scheme="https://liupei.link/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://liupei.link/tags/k8s/"/>
    
  </entry>
  
</feed>
