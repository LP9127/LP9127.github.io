<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liupei.link/"/>
  <updated>2022-09-12T04:54:50.135Z</updated>
  <id>https://liupei.link/</id>
  
  <author>
    <name>liupei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知行合一</title>
    <link href="https://liupei.link/2022/09/12/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/"/>
    <id>https://liupei.link/2022/09/12/知行合一/</id>
    <published>2022-09-12T04:43:05.000Z</published>
    <updated>2022-09-12T04:54:50.135Z</updated>
    
    <content type="html"><![CDATA[<p>之前对知行合一的理解是，如果你真的知道一件事情是正确的，那就会付出行动去落实，因为总会听到这样一句话“知道很多的道理，却过不好这一生”，结合知行合一，对这句话的解释是然“因为不是真正的知道这些道理，所以才没有行动，所以过不好”。</p><p>最近结合工作上的一些事情，包括敏捷的一些实践，对知行合一有了新的理解，敏捷讲究的是小步快跑，也就是说，不是先把方案什么的都做的很完美，才开始开发，而是先根据业务方的诉求，进行一个版本的开发，然后获得及时的反馈之后，再调整，再开发，直到达到业务方的要求。这个过程就是在“行中知”，“知中行”，感觉是“知行合一”的另一层意思。</p><p>其实对于一件要做的事情，永远不会觉得自己完全准备好了，最好的办法是，先做，然后再不断调整和完善，如果一直觉得没准备好，而畏畏缩缩不敢行动，那才是愚蠢的做法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前对知行合一的理解是，如果你真的知道一件事情是正确的，那就会付出行动去落实，因为总会听到这样一句话“知道很多的道理，却过不好这一生”，结合知行合一，对这句话的解释是然“因为不是真正的知道这些道理，所以才没有行动，所以过不好”。&lt;/p&gt;
&lt;p&gt;最近结合工作上的一些事情，包括
      
    
    </summary>
    
    
      <category term="说说" scheme="https://liupei.link/tags/%E8%AF%B4%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>20220911芭蕾日记</title>
    <link href="https://liupei.link/2022/09/11/20220911%E8%8A%AD%E8%95%BE%E6%97%A5%E8%AE%B0/"/>
    <id>https://liupei.link/2022/09/11/20220911芭蕾日记/</id>
    <published>2022-09-11T15:02:36.000Z</published>
    <updated>2022-09-11T15:29:33.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="frappe"><a href="#frappe" class="headerlink" title="frappe"></a>frappe</h3><p>之前关于这个动作练习的非常少，今天第一次练frappe组合，有点慌乱，主要是收回来勾脚，弹出去绷脚，勾绷脚不够灵活，而且速度也跟不太上，还是练习的少</p><h3 id="developpe"><a href="#developpe" class="headerlink" title="developpe"></a>developpe</h3><p>吸腿之后，出动力腿，膝盖尽量往上抬，抬到自己的极限之后，伸直动力腿，注意伸直的过程中膝盖不要掉下来，保证膝盖的高度，在这个高度上伸直腿，这样腿才会越抬越高</p><h3 id="一些自己的问题"><a href="#一些自己的问题" class="headerlink" title="一些自己的问题"></a>一些自己的问题</h3><p>今天上了一个新老师的课程，也指出了一些自己之前没有发现的问题</p><h4 id="1-塌腰"><a href="#1-塌腰" class="headerlink" title="1.塌腰"></a>1.塌腰</h4><p>主要还是核心没有收紧，没有一直保持肚脐眼去贴后背的感觉，中段是松的，其实是屁股没有收紧，除了要往里夹，还要往里转，这样才能把胯提起来</p><h4 id="2-斜方肌代偿"><a href="#2-斜方肌代偿" class="headerlink" title="2.斜方肌代偿"></a>2.斜方肌代偿</h4><p>因为背阔肌没有力量，因为架手位的时候，总是用斜方肌代偿，而且已经形成了习惯，感觉靠勤上课不能解决了，只能平常自己解决背部问题了，斜方肌已经习惯用力了，感觉不是很好改正</p><h4 id="3-X型腿"><a href="#3-X型腿" class="headerlink" title="3.X型腿"></a>3.X型腿</h4><p>因为膝盖内侧突出一块，经过老师鉴定，有点X型腿，因此站一位的时候，脚后跟不能合并上，一旦脚后跟合上，膝盖内部就会一前一后，或者挤得膝盖内侧疼，哎，这个通过后天没办法解决，毕竟是爹妈给的，腿就长这样</p><h4 id="4-髂腰肌力量不足"><a href="#4-髂腰肌力量不足" class="headerlink" title="4.髂腰肌力量不足"></a>4.髂腰肌力量不足</h4><p>芭蕾除了练习大腿内侧，在adagio抬腿的时候，更多的是用髂腰肌力量，目前都是用大腿内侧代偿，真害怕腿越练越粗，知道正确的发力很重要，功可以慢慢练，进步可以慢一点，但是要保证是在正确的方法下进步</p><h3 id="一点小分享"><a href="#一点小分享" class="headerlink" title="一点小分享"></a>一点小分享</h3><p>今天老师强调了换反面动作的时候，要从内侧转，随着老师说了句，也不知道为什么必须从内侧转，只是因为之前上学的时候老师要求的，所以这是一个课堂上的规定，大家遵守就好。正好我知道这个小知识，就分享给了老师和同学们，感到很开心</p><p>最近没什么食欲，吃饭很少，也好久没上课了，同学们都说我瘦了，看起来有瘦10斤，其实没有这么夸张，但是体重真的变轻了，看起来更“芭蕾“了，难道这就是”因祸得福“？不过还是希望自己不要太瘦，保持正常体重即可～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;frappe&quot;&gt;&lt;a href=&quot;#frappe&quot; class=&quot;headerlink&quot; title=&quot;frappe&quot;&gt;&lt;/a&gt;frappe&lt;/h3&gt;&lt;p&gt;之前关于这个动作练习的非常少，今天第一次练frappe组合，有点慌乱，主要是收回来勾脚，弹出去绷脚，勾绷脚不
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>20220902随想</title>
    <link href="https://liupei.link/2022/09/02/20220902%E9%9A%8F%E6%83%B3/"/>
    <id>https://liupei.link/2022/09/02/20220902随想/</id>
    <published>2022-09-02T15:16:18.000Z</published>
    <updated>2022-09-02T15:37:46.012Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最后一次"><a href="#最后一次" class="headerlink" title="最后一次"></a>最后一次</h3><p>下周就要去新大楼办公了，也意味着今天是在创维最后一天办公了，看着大家打包完的箱子，还真的有点舍不得，毕竟从一开始工作，就一直在创维办公，算了算，已经有4年多了，上个大学，也不过才4年；想起在创维第一次打卡，还是个戴蓝色工绳稚嫩的实习生，今天在创维最后一次打卡后，就告别这个熟悉的地方啦</p><h3 id="一寸光阴一寸金"><a href="#一寸光阴一寸金" class="headerlink" title="一寸光阴一寸金"></a>一寸光阴一寸金</h3><p>最近突然意识到时间很宝贵，时间过去了，就再也没有了，不像下棋，这盘输了，复盘后可以再来一局，时间如果没有好好珍惜，过去了，就是过去了；有这种感觉，可能是因为有一次去上芭蕾课，被一起上课的两个十四五岁的妹妹叫阿姨开始的吧，有一种自己居然年龄已经这么大了的感觉；另一个原因可能是，最近看镜子里的自己，脸上已经开始出现细纹了，想起自己上大学那会，姐姐大概和我现在的年龄差不多，有一天我们在卫生间洗漱，她突然看着我说，羡慕我年轻，不回长皱纹，当时觉得没什么，只是没想到时间过得这么快，现在自己也有同样感觉了；既然意识到了时间的宝贵，那就好好珍惜吧</p><h3 id="做有价值的事情"><a href="#做有价值的事情" class="headerlink" title="做有价值的事情"></a>做有价值的事情</h3><p>最近对电视剧综艺什么的，提不起兴趣，以前没有这种感觉，可能最近事情有点多，有点焦虑吧，不过这也是一件好事情，可以让自己有时间想想，业余时间，应该怎么规划，才会让自己比较充实</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最后一次&quot;&gt;&lt;a href=&quot;#最后一次&quot; class=&quot;headerlink&quot; title=&quot;最后一次&quot;&gt;&lt;/a&gt;最后一次&lt;/h3&gt;&lt;p&gt;下周就要去新大楼办公了，也意味着今天是在创维最后一天办公了，看着大家打包完的箱子，还真的有点舍不得，毕竟从一开始工作，就一直
      
    
    </summary>
    
    
      <category term="说说" scheme="https://liupei.link/tags/%E8%AF%B4%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>芭蕾的起源和发展</title>
    <link href="https://liupei.link/2022/08/27/%E8%8A%AD%E8%95%BE%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E5%8F%91%E5%B1%95/"/>
    <id>https://liupei.link/2022/08/27/芭蕾的起源和发展/</id>
    <published>2022-08-27T15:55:55.000Z</published>
    <updated>2022-08-27T16:49:45.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="芭蕾的起源"><a href="#芭蕾的起源" class="headerlink" title="芭蕾的起源"></a>芭蕾的起源</h3><p>芭蕾由法语ballet音译而来，起源于意大利文艺复兴时期，十七世纪后期开始在法国发展并日臻完美，十九世纪末在俄罗斯进入最繁荣的时代。</p><h3 id="芭蕾的发展"><a href="#芭蕾的发展" class="headerlink" title="芭蕾的发展"></a>芭蕾的发展</h3><h4 id="宴会芭蕾"><a href="#宴会芭蕾" class="headerlink" title="宴会芭蕾"></a>宴会芭蕾</h4><p>芭蕾出现于15-16世纪文艺复兴全盛时期的意大利，艺术家极力模仿古希腊的艺术风格。最早的芭蕾表演是在宫廷宴会上进行的，1489年在意大利的一个小城里，为庆祝米兰公爵和西班牙阿拉贡公主伊达贝尔的婚礼，演出了《奥菲士》。当时的表演形式与我们今天所见到的芭蕾演出绝然不同，它的每一段表演大致都与上菜联系在一起，比如模拟狩猎的表演开始以后就吃野猪肉；海洋、河流神灵出场开始吃鱼。然后，许多神话人物上场献上许多菜肴和水果，最后客人们也都参加到热闹狂欢的表演中去。这是一种把歌、舞、朗诵、戏剧表演综合起来的表演形式，可以说是芭蕾的雏形，后人称它为“宴会芭蕾”。</p><h4 id="宫廷芭蕾"><a href="#宫廷芭蕾" class="headerlink" title="宫廷芭蕾"></a>宫廷芭蕾</h4><p>随着意大利贵族与法国宫廷的通婚，意大利的“芭蕾”演出被带入法国，1581年，在亨利三世皇后妹妹——玛格丽特的结婚庆典上演出了《皇后的喜剧芭蕾》。当时没有舞台，观众坐在三面墙壁的两层楼廊里。国王和显贵们坐在坛台上，表演则在大厅的地板上进行。编导者博若瓦叶就是受聘于法国的意大利人。内容表现女妖西尔瑟如何征服了阿波罗，但不貌幌騕法兰西国王陛下屈服。表演是戏剧、音乐、舞蹈、朗诵、杂技的混合体。路易十四时期（1643-1715），法国芭蕾发展到它的鼎盛时期，路易十四本人喜爱舞蹈，并受过良好训练。15岁即参加宫廷芭蕾《卡珊德拉》的演出，扮演阿波罗神。</p><h4 id="情节芭蕾"><a href="#情节芭蕾" class="headerlink" title="情节芭蕾"></a>情节芭蕾</h4><p>十八世纪后期，芭蕾大师诺韦尔在1760年出版的《舞蹈与舞剧书信集》中首次提出了情节芭蕾的主张，强调舞蹈不只是形体的技巧，而是属于戏剧表现和思想交流的工具。这一理论推动了芭蕾的革新浪潮，在许多演员、编导的持续努力下，芭蕾从内容、题材、音乐、技术、服饰等方面都进行了一系列改革，使芭蕾最终与歌剧分离，成为一门独立的剧场艺术。</p><h4 id="浪漫芭蕾"><a href="#浪漫芭蕾" class="headerlink" title="浪漫芭蕾"></a>浪漫芭蕾</h4><p>十九世纪，法国巴黎进入了浪漫芭蕾的黄金时期，推出了《仙女》（1832）、《吉赛尔》（1841）等传世之作。</p><h4 id="古典芭蕾"><a href="#古典芭蕾" class="headerlink" title="古典芭蕾"></a>古典芭蕾</h4><p>十九世纪下半叶，俄罗斯进入了<strong>古典芭蕾</strong>的鼎盛时期，留下了《胡桃夹子》（1892）、《天鹅湖》（1895）等经典剧目。</p><h3 id="世界公认的顶级古典芭蕾舞团"><a href="#世界公认的顶级古典芭蕾舞团" class="headerlink" title="世界公认的顶级古典芭蕾舞团"></a>世界公认的顶级古典芭蕾舞团</h3><ul><li><p>前苏联的基洛夫芭蕾舞团</p></li><li><p>莫斯科年夜剧院芭蕾舞团</p></li><li><p>美国的纽约市芭蕾舞团</p></li><li><p>美国芭蕾舞剧院</p></li><li><p>英国的皇家芭蕾舞团</p></li><li><p>法国巴黎歌剧院芭蕾舞团</p></li><li><p>丹麦的皇家芭蕾舞团</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;芭蕾的起源&quot;&gt;&lt;a href=&quot;#芭蕾的起源&quot; class=&quot;headerlink&quot; title=&quot;芭蕾的起源&quot;&gt;&lt;/a&gt;芭蕾的起源&lt;/h3&gt;&lt;p&gt;芭蕾由法语ballet音译而来，起源于意大利文艺复兴时期，十七世纪后期开始在法国发展并日臻完美，十九世纪末在俄罗斯进
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>java中的运算符</title>
    <link href="https://liupei.link/2022/08/24/java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://liupei.link/2022/08/24/java中的运算符/</id>
    <published>2022-08-24T14:38:17.000Z</published>
    <updated>2022-08-24T14:56:59.358Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是运算符"><a href="#1-什么是运算符" class="headerlink" title="1.什么是运算符"></a>1.什么是运算符</h4><ul><li><p>运算符是对一个值或者多个值进行计算，并得出计算结果</p></li><li><p>运算结果的类型有时候是固定的，有时候是根据运算结果来的（两个int相加的结果类型是int，两个bype相加的结果类型是int）</p></li><li><p>除赋值运算外，计算并不会改变变量的值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b3 = b1+b2; <span class="comment">//这里IDE会有错误提示，b3的值必须是int</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是：</p><p>3</p><p>2</p><h4 id="2-取模运算符"><a href="#2-取模运算符" class="headerlink" title="2.取模运算符 %"></a>2.取模运算符 %</h4><ul><li><p>可以计算余数</p></li><li><p>负数可以取模</p></li><li><p>负数也可以被取模</p></li><li><p>小数也可以取模（基本不会遇到小数取模的场景）</p></li><li><p>取模的结果是正数还是负数，和%前面的数字是正还是负，是一致的</p></li><li><p>%后的数如果是0，java会报错</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println( a % <span class="number">2</span>);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % -<span class="number">2</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % <span class="number">3</span>);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % -<span class="number">6</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = -<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println( a % <span class="number">2</span>);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % -<span class="number">2</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % <span class="number">3</span>);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">        System.out.println( a % -<span class="number">6</span>); <span class="comment">// -4</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-整数的除法运算"><a href="#3-整数的除法运算" class="headerlink" title="3.整数的除法运算"></a>3.整数的除法运算</h4><ul><li><p>int类型除以int类型，结果还是int类型，不会是浮点数</p></li><li><p>如果想要结果是浮点数，则除数和被除数，其中一个是浮点数即可</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a / b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a / b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>3.3333333333333335</p><h4 id="4-比较运算符和布尔运算符"><a href="#4-比较运算符和布尔运算符" class="headerlink" title="4.比较运算符和布尔运算符"></a>4.比较运算符和布尔运算符</h4><p>比较运算符</p><ul><li><blockquote></blockquote></li><li><p>&gt;=</p></li><li><p>&lt;</p></li><li><p>&lt;=</p></li><li><p>!=</p></li><li><p>==</p></li></ul><p>布尔运算符（一般用&amp;&amp; 和 ||，而不用&amp; 和 ｜）</p><ul><li><p>! 非运算符,not运算符；!true=false ; !false=true</p></li><li><p>&amp; 与运算符，只要有一个为false，结果就是false</p></li><li><p>&amp;&amp; 与运算符，运算结果和&amp;一样</p></li><li><p>| 或运算符，只要有一个为true，结果就为true</p></li><li><p>|| 或运算符，运算结果和|一样 （区别在于，如果使用的是||，那只要第一个操作数已经是true了，就不会在计算后一个操作数是true还是false，但是如果使用的是｜，会把两个操作数的结果都计算出来，然后再比较）</p></li></ul><h4 id="5-小括号运算符"><a href="#5-小括号运算符" class="headerlink" title="5.小括号运算符"></a>5.小括号运算符</h4><ul><li>小括号运算符中可以包含任何运算符，小括号决定了运算的顺序</li></ul><h4 id="6-运算符的优先级"><a href="#6-运算符的优先级" class="headerlink" title="6.运算符的优先级"></a>6.运算符的优先级</h4><ul><li><p>( )</p></li><li><p>!</p></li><li><p>*,/,%</p></li><li><p>+,-</p></li><li><p>&gt;,&gt;=,&lt;,&lt;=</p></li><li><p>==</p></li><li><p>!=</p></li><li><p>&amp;,&amp;&amp;,|,||</p></li><li><p>=</p></li></ul><p>为什么赋值运算符优先级最低：因为要选把所有操作数计算完才能赋值</p><p>为什么布尔运算符的优先级低于比较运算符：因为要先比较完大小，得到true或false的结论，才能进行true和false的运算</p><p>为什么比较运算符的优先级低于算数运算符：因为要先进行计算，然后再拿结果比较大小</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-什么是运算符&quot;&gt;&lt;a href=&quot;#1-什么是运算符&quot; class=&quot;headerlink&quot; title=&quot;1.什么是运算符&quot;&gt;&lt;/a&gt;1.什么是运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运算符是对一个值或者多个值进行计算，并得出计算结果&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://liupei.link/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>认识数组</title>
    <link href="https://liupei.link/2022/08/24/%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/"/>
    <id>https://liupei.link/2022/08/24/认识数组/</id>
    <published>2022-08-24T00:55:32.000Z</published>
    <updated>2022-08-24T00:59:42.632Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-重新认识基本类型的变量"><a href="#1-重新认识基本类型的变量" class="headerlink" title="1.重新认识基本类型的变量"></a>1.重新认识基本类型的变量</h4><ul><li><p>变量的基本逻辑——有定才有变，在人看来，变量固定的是名字，改变的是值；但是在计算机看来，不变的是地址，变化的是值</p></li><li><p>理解计算机如何使用内存，完成变量的功能</p><pre><code>（1）内存就是一堆白纸，只能通过页码编号访问，也就是所谓的内存地址（2）变量就是使用一个固定的地址加上这个地址对应的内存；计算机通过地址，读写地址对应的内存值，完成变量的赋值和访问值的功能，就好像根据页面编号在白纸上写字，然后擦掉再重复写的过程（3）变量的名就是地址，变量的实就是地址的内存值</code></pre></li></ul><h4 id="2-认识数组"><a href="#2-认识数组" class="headerlink" title="2.认识数组"></a>2.认识数组</h4><p><strong>理解数组的名与实</strong></p><ul><li><p>数组的实是一块地址连续的内存，就像是编号连续的一踏白纸</p></li><li><p>数组的名，就是这个连续内存的第一个内存的地址</p></li><li><p>数组的变量和基本变量一样，本身是个地址；但是与变量不一样的是，这个地址的值，是数组的“名”，也就是数组的第一个地址</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><strong>创建数组的过程是</strong></p><ul><li><p>先new一个指定长度的数组（就是一块连续的地址）</p></li><li><p>然后把这一块连续地址中第一个地址的值赋值给变量book</p></li><li><p>book本身作为一个变量，也是有地址的（比如book的地址），然后book这个变量的值就是new出来的那一块连续地址中的第一个地址</p></li></ul><p><strong>数组=数组变量+数组的实体</strong></p><ul><li><p>数组变量[索引]就是在数组原有地址的基础上，加上索引，获得想要的元素</p></li><li><p>所以索引是从0开始的，因为索引变量的值就是数组第一个元素的地址，不需要加一</p></li></ul><h4 id="3-数组的长度"><a href="#3-数组的长度" class="headerlink" title="3.数组的长度"></a>3.数组的长度</h4><ul><li><p>数组变量.length可以获得数组的长度</p></li><li><p>数组创建之后，长度不可以改变</p></li></ul><h4 id="4-数组索引过界和初始值"><a href="#4-数组索引过界和初始值" class="headerlink" title="4.数组索引过界和初始值"></a>4.数组索引过界和初始值</h4><ul><li><p>访问数组过界出错，报错 IndexOutOfBoundsException</p></li><li><p>如果没有把握数组是否会出界，可以把索引和数组长度做比较，注意索引是从0开始，不是从1开始</p></li><li><p>数组中每个元素都有初始值，初始值和类型有关，对于数字类型，初始值是0，boolean类型，初始值是false</p></li></ul><h4 id="5-让数组变量指向新的数组"><a href="#5-让数组变量指向新的数组" class="headerlink" title="5.让数组变量指向新的数组"></a>5.让数组变量指向新的数组</h4><ul><li><p>数组变量可以指向新的数组实体，这时候，数组变量的值就是新的数组实体的地址；这种数组变量的赋值操作，叫做让变量指向新的数组</p></li><li><p>如果没有别的数组变量指向原来的数组实体，也就是说，如果没有变量记得原来数组的地址，原来的数组实体也就不可访问，相当于“消失”了</p></li><li><p>对于非基本类型的变量，计算机都要通过这种“两级跳”的方式实现，基本类型变量，“一跳”就可以</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhatArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(array[array.length-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        System.out.println(<span class="string">"数组array1的长度是"</span> + array1.length);</span><br><span class="line"></span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(<span class="string">"数组array1的长度是"</span> + array1.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>输出：</p><p>0</p><p>数组array1的长度是2</p><p>数组array1的长度是3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-重新认识基本类型的变量&quot;&gt;&lt;a href=&quot;#1-重新认识基本类型的变量&quot; class=&quot;headerlink&quot; title=&quot;1.重新认识基本类型的变量&quot;&gt;&lt;/a&gt;1.重新认识基本类型的变量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;变量的基本逻辑——有定才有变，在人
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://liupei.link/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>20220821芭蕾日记</title>
    <link href="https://liupei.link/2022/08/22/20220821%E8%8A%AD%E8%95%BE%E6%97%A5%E8%AE%B0/"/>
    <id>https://liupei.link/2022/08/22/20220821芭蕾日记/</id>
    <published>2022-08-22T00:57:25.000Z</published>
    <updated>2022-08-24T14:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软开"><a href="#软开" class="headerlink" title="软开"></a>软开</h3><p>1.横叉每周都肉眼可见的进步，很欣慰，在软开这种事情上，努力了就一定会有回报，就已经是一件很值得开心的事情了，毕竟不是每件事情，努力了就一定会有回报；撕胯依然很疼很难忍，平常自己也可以稍微练习下，不至于一上课就戴上痛苦面具</p><p>2.不知道为什么竖叉都可以下，但是前屈很差，今天和一起上课的姐妹聊天，她指出应该是后背的问题，看来前屈问题只通过上课很难解决了，需要平常自己练习一下，毕竟上课的时候，两个同学加老师，三个人一起帮我练前屈，也太不容易了</p><p>3.老师帮踩后跨根的时候，不知道为什么膝盖会疼，老师让把重心放到没有被踩的那条腿上，可似乎并没有太多好转，下次上课再看看会不会有类似感觉</p><p>4.软开最疼的就是压脚背了，先不着急吧，先解决其他问题，再来计划压脚背</p><h3 id="基训"><a href="#基训" class="headerlink" title="基训"></a>基训</h3><p>1.后背有进步，但是不多，不知道为什么，今天上课，想分分钟摆烂，不过坚持一下也就是几分钟的事情，毕竟老师说再最想放弃的时候，再坚持一下是最涨功的</p><p>2.芭蕾越学，越觉得基础的东西掌握的不扎实，就比如手位，上课的第一节就开始学，但是现在感觉一个好的七位手自己也没有做得很标准，决定基础的课程再持续练习半年吧</p><h3 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h3><p>芭蕾和学习编程，本质上都是在学习一个新的技能</p><p>上周有和组里的开发同学聊到怎么学习一门新的编程语言，他的观点是，先不必拘泥于细节，先run起来，然后对于自己想深入的点，去重点学习和探索，因为如果一开始，就过于注重基础知识的细节，极大可能会丧失兴趣，难以持续，并且语言本身是为解决实际问题服务的，先运用起来，在不断的运用当中，会得到快速的成长</p><p>本来我觉得学习芭蕾这个技能和学习编程语言这个技能的方法相反，因为芭蕾是要基础非常扎实，才能往更高级的方向发展，但是今天跟一起上课的姐妹聊天，发现也不能一直都在打基础，也需要去抬头看看，去偶尔体验一下更高阶的课程是什么样子，一是可以给自己一个目标，二是会更加意识到基础的重要性，不然一直上基础课，也会感觉无聊，有时候甚至会无效上课</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软开&quot;&gt;&lt;a href=&quot;#软开&quot; class=&quot;headerlink&quot; title=&quot;软开&quot;&gt;&lt;/a&gt;软开&lt;/h3&gt;&lt;p&gt;1.横叉每周都肉眼可见的进步，很欣慰，在软开这种事情上，努力了就一定会有回报，就已经是一件很值得开心的事情了，毕竟不是每件事情，努力了就一定
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>20220820芭蕾日记</title>
    <link href="https://liupei.link/2022/08/20/20220820%E8%8A%AD%E8%95%BE%E6%97%A5%E8%AE%B0/"/>
    <id>https://liupei.link/2022/08/20/20220820芭蕾日记/</id>
    <published>2022-08-20T08:18:40.000Z</published>
    <updated>2022-08-20T09:11:02.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="把杆组合"><a href="#把杆组合" class="headerlink" title="把杆组合"></a>把杆组合</h3><h4 id="Tendu"><a href="#Tendu" class="headerlink" title="Tendu"></a>Tendu</h4><p>1.在快的组合中，着重练习的是重心的运用和变化，目前在快的组合中，变重心太慢了，通常动作已经开始了，但是重心还没有转换过来；变重心的时机：上一个动作做完，就要迅速变重心，为下一个动作做准备</p><p>2.tendu中，老师指出来两个问题</p><ul><li><p>快的组合中，经过半脚掌的过程要明显一点，节奏虽然快了，但是要求没变，动作还是要做细致</p></li><li><p>所有的tendu都要开的出去，开的回来，这一点在快的组合中也容易忘记</p></li></ul><h4 id="Jete"><a href="#Jete" class="headerlink" title="Jete"></a>Jete</h4><p>1.问题一：jete擦地出去后，腿的高度太低了，要25度</p><p>2.jete讲究的是一个爆发力，一定要快，但是不是直接踢出去，要经过好的擦地，然后再出去</p><p>3.擦出去要快，收回来同样要快，通常都是擦出去的力量够了，但是回的时候力量不够，太慢了</p><h4 id="Passe"><a href="#Passe" class="headerlink" title="Passe"></a>Passe</h4><p>1.动力腿尽量往上提</p><p>2.主力腿的力量给的太少，同时半脚尖没有顶到头，半脚尖的力量还需要再多一点</p><h4 id="Rond-de-jembe"><a href="#Rond-de-jembe" class="headerlink" title="Rond de jembe"></a>Rond de jembe</h4><p>1.依旧是主力腿的力量太少，在抬起动力腿之前，需要保证两点，一是主力腿用力往下踩；另一个是主力腿那一侧的腰提起来，在这个基础上，再去抬动力腿</p><p>2.抬动力腿的时候，保证先绷脚，动力腿的脚一定要绷到头（虽然老师一直说用脚尖带着划，但是似乎没有特别感受到脚尖的力量，目前好像还是用大腿带着划的）</p><p>3.从旁到后，腿一定要伸直，膝盖伸直，保证高度不要下降太多</p><p>总结：目前Rond de jembe主要的问题还是，主力腿的力量太少，导致整个人都是堆在一起的，所以一方面使不上劲，另一方面整个人会有点歪，动力腿自然抬不高</p><h4 id="Releve-lent"><a href="#Releve-lent" class="headerlink" title="Releve lent"></a>Releve lent</h4><p>1.缓慢的抬起，缓慢的落下</p><p>2.回到passe，伸直的时候，动力腿要再伸直再延伸一下，然后再收回到passe</p><h4 id="Releve"><a href="#Releve" class="headerlink" title="Releve"></a>Releve</h4><p>今天才意识到，因为脚腕子力量不够，平常练习的时候，半脚尖都没有顶到头，顶到头虽然很累，但是感觉整个人都高了一截，并且好像也更稳了</p><h3 id="中间部分"><a href="#中间部分" class="headerlink" title="中间部分"></a>中间部分</h3><h4 id="Pile"><a href="#Pile" class="headerlink" title="Pile"></a>Pile</h4><p>今天突然发现，中间部分做pile的时候，grand pile也能完全蹲下去了，去年中间做grand pile非常不稳，很多时候整个人还没蹲不下去，人就要倒了，肉眼可见的进步了，非常开心～～～</p><h4 id="Adagio"><a href="#Adagio" class="headerlink" title="Adagio"></a>Adagio</h4><p>中间做adagio的时候，今天有一瞬间感觉到了，主力腿使劲往下踩，然后动力腿的脚尖带着动力腿往上的感觉，很惊喜！</p><h4 id="Saute"><a href="#Saute" class="headerlink" title="Saute"></a>Saute</h4><p>1.跳起来绷脚</p><p>2.肩膀要沉下去，不要耸起来</p><p>3.注意后背直立，身体不要向前趴</p><h4 id="Changement"><a href="#Changement" class="headerlink" title="Changement"></a>Changement</h4><p>五位跳起来，脚向里面再夹紧一下，然后再落下来</p><h3 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h3><h4 id="关于转开"><a href="#关于转开" class="headerlink" title="关于转开"></a>关于转开</h4><p>有好几次，在网上找如何转开的方法，但是今天上课过程中突然想到，转开其实不需要专门练习，上课的每一个动作都有转开意识，就是对转开最好的训练</p><p>转开并不是一个静态的过程，在运动的过程中，也要一直有转开的意识，一直转开，这样才能练习到正确的肌肉</p><h4 id="坚持就是胜利"><a href="#坚持就是胜利" class="headerlink" title="坚持就是胜利"></a>坚持就是胜利</h4><p>今天的跳跃很多，小跳+中跳，虽然最后已经快要累吐了，但是还是坚持跳完了所有组合，尤其是刚开始小跳没有很累的时候，感觉跳的很轻松，很愉悦，很开心，感觉比平常都跳的高了一些，恨不到再来两个小跳组合；不过后面的Echappe实在太累了，差点没跳完组合，希望下周还能找到今天的小跳状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;把杆组合&quot;&gt;&lt;a href=&quot;#把杆组合&quot; class=&quot;headerlink&quot; title=&quot;把杆组合&quot;&gt;&lt;/a&gt;把杆组合&lt;/h3&gt;&lt;h4 id=&quot;Tendu&quot;&gt;&lt;a href=&quot;#Tendu&quot; class=&quot;headerlink&quot; title=&quot;Tendu&quot;&gt;
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>Go各版本构建模式切换</title>
    <link href="https://liupei.link/2022/08/17/Go%E5%90%84%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E6%9C%BA%E5%88%B6%E5%88%87%E6%8D%A2/"/>
    <id>https://liupei.link/2022/08/17/Go各版本构建机制切换/</id>
    <published>2022-08-17T15:26:08.000Z</published>
    <updated>2022-08-17T15:50:28.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go各版本构建模式的切换"><a href="#Go各版本构建模式的切换" class="headerlink" title="Go各版本构建模式的切换"></a>Go各版本构建模式的切换</h3><p>Go不同版本的构建模式和机制不同，因此如果切换了Go的版本，相应的构建模式也要切换，否则会构建失败</p><p>1.只要GO111MODULE的值是on，无论是哪个版本，都开启Go Module模式</p><p>2.只要GO111MODULE的值是off，无论是哪个版本，都是GOPATH模式</p><p>3.小于1.13版本，项目路径在GPOPATH/src目录下 且 包含go.mod文件，则默认开启Go Module模式；否则使用GOPATH模式</p><p>4.等于1.13版本，只要当前目录或子目录下有go.mod文件，就开启Go Module模式；否则使用GOPATH模式</p><p>5.等于1.16版本，只要当前目录或子目录下有go.mod文件，就开启Go Module模式；否则使用GOPATH模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go各版本构建模式的切换&quot;&gt;&lt;a href=&quot;#Go各版本构建模式的切换&quot; class=&quot;headerlink&quot; title=&quot;Go各版本构建模式的切换&quot;&gt;&lt;/a&gt;Go各版本构建模式的切换&lt;/h3&gt;&lt;p&gt;Go不同版本的构建模式和机制不同，因此如果切换了Go的版本，
      
    
    </summary>
    
    
      <category term="Go" scheme="https://liupei.link/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入理解GoModule</title>
    <link href="https://liupei.link/2022/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GoModule/"/>
    <id>https://liupei.link/2022/08/16/深入理解GoModule/</id>
    <published>2022-08-16T14:55:05.000Z</published>
    <updated>2022-08-16T17:02:46.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-语义版本机制"><a href="#1-语义版本机制" class="headerlink" title="1.语义版本机制"></a>1.语义版本机制</h3><h4 id="1-1-什么是语义版本规范"><a href="#1-1-什么是语义版本规范" class="headerlink" title="1.1 什么是语义版本规范"></a>1.1 什么是语义版本规范</h4><p>按照Go Module构建模式，一个符合Go Module要求的版本号，需要按照语义版本规范组成</p><p>语义版本规范：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0 | Semantic Versioning</a></p><p><img src="file:///Users/liupei/Library/Application%20Support/marktext/images/2022-08-16-23-12-25-image.png" title alt width="235"></p><p>主版本号：主版本号不同的两个版本是互不兼容的</p><p>次版本号：主版本号相同的情况下，次版本号的大的，兼容次版本号小的</p><p>补丁版本号：主版本号和次版本号相同，补丁版本号大的兼容补丁版本号小的</p><h4 id="1-2-Go-Module如何使用语义版本规范"><a href="#1-2-Go-Module如何使用语义版本规范" class="headerlink" title="1.2 Go Module如何使用语义版本规范"></a>1.2 Go Module如何使用语义版本规范</h4><p>1.当新旧两个包是相互兼容的，那包的导入路径应该是相同的</p><p>eg：如果项目依赖 github.com/sirupsen/logrus 这个包，不管依赖的是这个包的v1.7.1版本还是  v1.8.1版本，包的导入路径都是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> github.com/sirupsen/logrus</span><br></pre></td></tr></table></figure><p>2.如果新旧两个包不兼容，则包的导入路径不同，导入路径通过在包后面加主版本号的方式区分</p><p>eg：如果项目之前依赖github.com/sirupsen/logrus 这个包的v1.7.1，后面需要依赖 v2.7.1版本，那包的导入路径就要变为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> github.com/sirupsen/logrus/v2</span><br></pre></td></tr></table></figure><p>3.如果主版本号是v0或者v1，则包的导入路径后不用跟主版本号</p><p>eg：不管项目依赖github.com/sirupsen/logrus 这个包的v0.7.1还是v1.7.1版本，包的导入路径都是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> github.com/sirupsen/logrus</span><br></pre></td></tr></table></figure><h3 id="2-Go-Module的最小版本选择原则"><a href="#2-Go-Module的最小版本选择原则" class="headerlink" title="2.Go Module的最小版本选择原则"></a>2.Go Module的最小版本选择原则</h3><p>eg:</p><p><img src="/Users/liupei/Library/Application%20Support/marktext/images/2022-08-17-00-38-00-image.png" alt></p><p>上图的这种情况，根据Go Module的最小版本选择原则，最终会使用C v1.3.0版本，而不会使用v 1.7.0版本</p><p>原因是：对于这个项目来说C v1.3.0版本就够用了，引入更高级别的版本，虽然也可以兼容，但是增加了不稳定性 </p><h3 id="3-Go-Module的6类常规操作"><a href="#3-Go-Module的6类常规操作" class="headerlink" title="3.Go Module的6类常规操作"></a>3.Go Module的6类常规操作</h3><h4 id="3-1-为当前module添加一个依赖"><a href="#3-1-为当前module添加一个依赖" class="headerlink" title="3.1 为当前module添加一个依赖"></a>3.1 为当前module添加一个依赖</h4><p>1.手动在源码中通过import语句导入依赖包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> github.com/google/uuid</span><br></pre></td></tr></table></figure><p>2.下载依赖包并更新go.mod文件</p><ul><li>方式一：使用go get命令，下载依赖包到本地module缓存里，并更新go.mod文件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> get github.com/google/uuid</span><br></pre></td></tr></table></figure><ul><li>方式二（推荐）：使用go mod tidy命令，自动检测，自动下载依赖包并更新go.mod文件</li></ul><h4 id="3-2-升级-降级当前依赖的版本（主版本号相同）"><a href="#3-2-升级-降级当前依赖的版本（主版本号相同）" class="headerlink" title="3.2 升级/降级当前依赖的版本（主版本号相同）"></a>3.2 升级/降级当前依赖的版本（主版本号相同）</h4><p>1.首先如果升级/降级后的依赖版本和当前版本的版本号相同，就不用修改源代码中的import导入语句</p><p>2.修改go.mod文件</p><ul><li>方式一：使用go get命令，下载升级/降级后的依赖包到本地module缓存里，并更新go.mod文件中依赖包的版本号到升级/降级后的版本</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> get github.com/sirupsen/logrus@v1<span class="number">.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><ul><li>方式二：先使用go mod edit命令，告知我们需要的升级/降级后的版本，然后再使用go mod tidy命令下载依赖包并更新go.mod文件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> mod edit -require=github.com/sirupsen/logrus@v1<span class="number">.7</span><span class="number">.0</span></span><br><span class="line">$<span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure><h4 id="3-3-升级当前依赖版本到一个不兼容的版本"><a href="#3-3-升级当前依赖版本到一个不兼容的版本" class="headerlink" title="3.3 升级当前依赖版本到一个不兼容的版本"></a>3.3 升级当前依赖版本到一个不兼容的版本</h4><p>1.先修改源代码中import导入的依赖包</p><p>2.使用go get命令，下载升级后的依赖包并更新go.mod文件</p><h4 id="3-4-添加一个主版本号大于1的依赖"><a href="#3-4-添加一个主版本号大于1的依赖" class="headerlink" title="3.4 添加一个主版本号大于1的依赖"></a>3.4 添加一个主版本号大于1的依赖</h4><p>1.先修改源代码中import导入的依赖包</p><p>2.使用go get命令，下载升级后的依赖包并更新go.mod文件</p><h4 id="3-5-移除一个依赖"><a href="#3-5-移除一个依赖" class="headerlink" title="3.5 移除一个依赖"></a>3.5 移除一个依赖</h4><p>1.先删除源代码中import导入的依赖包</p><p>2.使用go mod tidy命令，自动分析，自动移除依赖包，自动更新go.mod文件</p><h4 id="3-6-使用vendor机制"><a href="#3-6-使用vendor机制" class="headerlink" title="3.6 使用vendor机制"></a>3.6 使用vendor机制</h4><p>如果使用vendor机制，进行构建时，就会从vendor目录下拉取依赖包，而不是从GoModule的本地缓存中拉取依赖包</p><p>如果有特殊情况要使用vendor机制</p><p>1.使用go build命令构建时，需要加参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -mod=vendor</span><br></pre></td></tr></table></figure><p>2.Go v1.14版本后，如果根目录下有vendor目录，则默认使用vendor机制，如果还是想使用Go Module，需要的命令如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -mod=mod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-语义版本机制&quot;&gt;&lt;a href=&quot;#1-语义版本机制&quot; class=&quot;headerlink&quot; title=&quot;1.语义版本机制&quot;&gt;&lt;/a&gt;1.语义版本机制&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是语义版本规范&quot;&gt;&lt;a href=&quot;#1-1-什么是语义版本规范&quot; c
      
    
    </summary>
    
    
      <category term="Go" scheme="https://liupei.link/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go构建模式</title>
    <link href="https://liupei.link/2022/08/15/Go%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liupei.link/2022/08/15/Go构建模式/</id>
    <published>2022-08-15T13:54:47.000Z</published>
    <updated>2022-08-15T14:39:58.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Go构建模式的演化"><a href="#1-Go构建模式的演化" class="headerlink" title="1.Go构建模式的演化"></a>1.Go构建模式的演化</h3><h4 id="1-1-什么是Go的构建模式"><a href="#1-1-什么是Go的构建模式" class="headerlink" title="1.1 什么是Go的构建模式"></a>1.1 什么是Go的构建模式</h4><p>Go程序的构建过程就是确定包版本，编译包以及将编译后得到的目标文件链接在一起的过程</p><h4 id="1-2-GOPATH的构建模式"><a href="#1-2-GOPATH的构建模式" class="headerlink" title="1.2 GOPATH的构建模式"></a>1.2 GOPATH的构建模式</h4><p>1.GOPATH构建模式的构建过程</p><ul><li><p>在GOPATH构建模式下，Go编译的时候，会在GOPATH的环境变量目录下寻找依赖的第三方包，如果找到了，就使用这个第三方包进行编译，没找到，就会报编译错误</p></li><li><p>如果在本地没有找到第三方包，可以使用go get命令，将第三方包以及第三方包的依赖包下载到本地</p></li></ul><p>在Mac或Linux上，GPOPATH的默认环境变量目录是 $HOME/go</p><p>2.GOPATH构建模式的缺点</p><ul><li><p>go get获取到的时候当前时刻，第三方包的依赖版本，随着时间的演进，第三方包也会更新版本，这样就会导致不同时期获取到的第三方包版本不一样</p></li><li><p>因为go get获取的是最新版本，因此当第三方包的最新版本有bug，也会一直影响程序构建</p></li></ul><p>在GOPATH构建模式下，Go编译器没有关注第三方依赖包的版本</p><h4 id="1-3-vendor机制"><a href="#1-3-vendor机制" class="headerlink" title="1.3 vendor机制"></a>1.3 vendor机制</h4><p>1.什么是vendor机制</p><p>在项目的vendor目录下，将项目所依赖的第三方包缓存起来</p><p>2.vendor机制解决了什么问题</p><p>只要有vendor目录，Go程序会优先使用vendor下缓存的第三方包，不会优先使用GOPATH环境变量目录下的第三方包，因此提交代码的时候，如果将vendor目录一并提交，那其他开发者拉取代码之后，就可以直接进行构建</p><p>3.开启vendor机制的必要条件</p><p>Go项目必须位于GOPATH环境变量配置的某个路径的src目录下面</p><p>4.vendor机制的缺点</p><ul><li><p>Go项目必须位于GOPATH环境变量配置的某个路径的src目录下面</p></li><li><p>vendor目录必须提交到代码仓库，减慢了代码的提交和下载速度</p></li><li><p>开发者需要手工管理依赖包，包括依赖包的分析、版本记录、依赖包的获取等</p></li></ul><h4 id="1-4-Go-Module"><a href="#1-4-Go-Module" class="headerlink" title="1.4 Go Module"></a>1.4 Go Module</h4><p>1.什么是Go Module</p><ul><li><p>Go module是一些Go包的集合，这些包和 module 一起打版本、发布和分发。</p></li><li><p>通常一个代码仓库对应一个Go module</p></li></ul><p>2.go.mod文件</p><ul><li><p>go.mod文件放置在Go Module的顶层目录下</p></li><li><p>一个Go Module和一个go.mod文件一一对应，也就是说，一个Go Module只会存在一个go.mod文件</p></li></ul><p>3.如何创建一个Go Module</p><p><strong>第一步，通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module</strong></p><p>注意：在构建module时， go mod init $modulePath, 这个modulePath怎么写</p><p>modulePath的作用：</p><p>a.定位仓库的地址。如果代码开源到公共托管站点或者公司内部的代码仓库，那modulePath就要带上仓库的地址，这样其他依赖这个module才可以找得到</p><p>b.如果module不在根目录下，就是一个项目中可能有多个module，不在根目录下的module，modulePath中需要带上子目录路径</p><p>c.major版本号。如果major&gt;=2，需要在module path中加上major号后缀</p><p><strong>第二步，通过 go mod tidy 命令下载依赖并自动更新当前go.mod文件</strong></p><p>go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径</p><p><strong>第三步，执行 go build，执行新 module 的构建</strong></p><p>go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Go构建模式的演化&quot;&gt;&lt;a href=&quot;#1-Go构建模式的演化&quot; class=&quot;headerlink&quot; title=&quot;1.Go构建模式的演化&quot;&gt;&lt;/a&gt;1.Go构建模式的演化&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是Go的构建模式&quot;&gt;&lt;a href=&quot;#1-1
      
    
    </summary>
    
    
      <category term="Go" scheme="https://liupei.link/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>20220814芭蕾日记</title>
    <link href="https://liupei.link/2022/08/14/20220814%E8%8A%AD%E8%95%BE%E7%AC%94%E8%AE%B0/"/>
    <id>https://liupei.link/2022/08/14/20220814芭蕾笔记/</id>
    <published>2022-08-14T15:08:25.000Z</published>
    <updated>2022-08-20T08:18:17.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软开"><a href="#软开" class="headerlink" title="软开"></a>软开</h3><p>横叉度秒如年，不过今天横叉坚持了很久，也有比较大的进步，痛并快乐～不知道为什么，咬牙坚持了很久，当和我一组的小姐姐问老师我是不是可以下了，因为我已经趴很久了的时候，尽管老师说再趴2min，但还是忍不住了，太酸爽了，下周继续努力吧</p><h3 id="基训"><a href="#基训" class="headerlink" title="基训"></a>基训</h3><h4 id="1-地面坐姿"><a href="#1-地面坐姿" class="headerlink" title="1.地面坐姿"></a>1.地面坐姿</h4><p>后背太拉垮了，后背没有力气，加上腹部力量也不够，不能一直保持后背向上，好无奈，把老师都气笑了，下个阶段要重点解决腹背肌</p><h4 id="2-转开练习"><a href="#2-转开练习" class="headerlink" title="2.转开练习"></a>2.转开练习</h4><p>整个下半身都酸酸酸，上课感觉没有转的很开，但是下课后感觉屁股很酸，假装是用对肌肉了吧，地面还是要多练，把杆才能更稳</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软开&quot;&gt;&lt;a href=&quot;#软开&quot; class=&quot;headerlink&quot; title=&quot;软开&quot;&gt;&lt;/a&gt;软开&lt;/h3&gt;&lt;p&gt;横叉度秒如年，不过今天横叉坚持了很久，也有比较大的进步，痛并快乐～不知道为什么，咬牙坚持了很久，当和我一组的小姐姐问老师我是不是可以下了，因
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>Go程序的结构</title>
    <link href="https://liupei.link/2022/08/14/Go%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>https://liupei.link/2022/08/14/Go程序的结构/</id>
    <published>2022-08-14T06:04:57.000Z</published>
    <updated>2022-08-15T14:40:02.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-一个最基本的Go程序"><a href="#1-一个最基本的Go程序" class="headerlink" title="1.一个最基本的Go程序"></a>1.一个最基本的Go程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//定义一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> <span class="comment">//声明fmt包的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//main函数</span></span><br><span class="line">    fmt.Println(<span class="string">"hello, world"</span>) <span class="comment">//Println函数定义于fmt包中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-包的概念"><a href="#1-1-包的概念" class="headerlink" title="1.1 包的概念"></a>1.1 包的概念</h4><ul><li><p>包（package）是Go语言的基本组成单元，一个Go程序本质上就是一组包的集合</p></li><li><p>整个Go程序中只能存在一个main包</p></li></ul><h4 id="1-2-main函数"><a href="#1-2-main函数" class="headerlink" title="1.2 main函数"></a>1.2 main函数</h4><p>当执行一个可执行的Go程序时，程序执行的入口就是main函数</p><h4 id="1-3-声明包的导入路径"><a href="#1-3-声明包的导入路径" class="headerlink" title="1.3 声明包的导入路径"></a>1.3 声明包的导入路径</h4><p>import “fmt”指的是，导入标准库fmt目录下的包</p><h4 id="1-4-fmt包"><a href="#1-4-fmt包" class="headerlink" title="1.4 fmt包"></a>1.4 fmt包</h4><p>fmt.Println(“hello, world”)中的fmt指的是包名，和import “fmt”中的fmt不一样</p><h4 id="1-5-Println函数"><a href="#1-5-Println函数" class="headerlink" title="1.5 Println函数"></a>1.5 Println函数</h4><p>Println函数位于标准库fmt目录下的fmt包中，Println的首字母大写，代表对fmt包外的代码可见，如果全部是小写，代表只在声明它的包内可见</p><h3 id="2-Go程序的编译和执行"><a href="#2-Go程序的编译和执行" class="headerlink" title="2.Go程序的编译和执行"></a>2.Go程序的编译和执行</h3><h4 id="2-1-使用go-build命令进行编译"><a href="#2-1-使用go-build命令进行编译" class="headerlink" title="2.1 使用go build命令进行编译"></a>2.1 使用go build命令进行编译</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build main.<span class="keyword">go</span><span class="comment">//编译，得到一个二进制文件</span></span><br><span class="line">$ ./main  <span class="comment">//执行</span></span><br></pre></td></tr></table></figure><p>使用go build命令进行编译，编译成功后得到一个可执行二进制文件，这个二进制文件在没有go的环境中也可以执行</p><h4 id="2-2-使用go-run命令可直接执行go源文件"><a href="#2-2-使用go-run命令可直接执行go源文件" class="headerlink" title="2.2 使用go run命令可直接执行go源文件"></a>2.2 使用go run命令可直接执行go源文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>go run命令更多的是开发和调试阶段使用，在实际的项目中要先使用go build进行构建</p><h3 id="3-Go-module"><a href="#3-Go-module" class="headerlink" title="3.Go module"></a>3.Go module</h3><blockquote><p>Go module是Go默认的包依赖管理机制和Go源码构建机制。</p><p>一个 module 就是一些包的集合，这些包和 module 一起打版本、发布和分发。</p><p>Go Module 的核心是一个名为 go.mod 的文件，在这个文件中存储了这个 module 对第三方依赖的全部信息。</p></blockquote><h4 id="3-1-go-mod文件的生成"><a href="#3-1-go-mod文件的生成" class="headerlink" title="3.1 go.mod文件的生成"></a>3.1 go.mod文件的生成</h4><p>进入目标目录，执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init github.com/hellomodule  <span class="comment">//go mod 初始化的时候一般用源代码存储仓库，使 go 工具能下载到，如果只是本地测试可以随便起名，如: example/hellomodule</span></span><br></pre></td></tr></table></figure><p>执行完成之后，在目标目录下成功一个go.mod文件，这个目标目录称为被声明的module的根目录</p><h4 id="3-2-添加依赖包的版本信息"><a href="#3-2-添加依赖包的版本信息" class="headerlink" title="3.2 添加依赖包的版本信息"></a>3.2 添加依赖包的版本信息</h4><ul><li><p>手动添加</p></li><li><p>使用go mod tidy命令自动添加</p></li></ul><h4 id="3-3-go-sum文件"><a href="#3-3-go-sum文件" class="headerlink" title="3.3 go.sum文件"></a>3.3 go.sum文件</h4><blockquote><p>go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建</p></blockquote><blockquote><p>推荐把 go.mod 和 go.sum 两个文件与源码，一并提交到代码版本控制服务器上</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-一个最基本的Go程序&quot;&gt;&lt;a href=&quot;#1-一个最基本的Go程序&quot; class=&quot;headerlink&quot; title=&quot;1.一个最基本的Go程序&quot;&gt;&lt;/a&gt;1.一个最基本的Go程序&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="Go" scheme="https://liupei.link/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>20220813芭蕾日记</title>
    <link href="https://liupei.link/2022/08/13/20220813%E8%8A%AD%E8%95%BE%E6%97%A5%E8%AE%B0/"/>
    <id>https://liupei.link/2022/08/13/20220813芭蕾日记/</id>
    <published>2022-08-13T15:18:55.000Z</published>
    <updated>2022-08-20T08:28:42.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="芭蕾基训"><a href="#芭蕾基训" class="headerlink" title="芭蕾基训"></a>芭蕾基训</h3><h4 id="Pile"><a href="#Pile" class="headerlink" title="Pile"></a>Pile</h4><p>1.grand pile的时候，Allonge呼吸手往下的时候，手要贴近身体划下来</p><p>2.四位grand pile的时候，后腿要保持转开</p><p>3.grand pile起来的时候，脚后跟主动踩，然后经过demi pile再起来</p><h4 id="Tendu"><a href="#Tendu" class="headerlink" title="Tendu"></a>Tendu</h4><p>1.在快的组合中，还是顾不上动作要点，问题主要有两个</p><ul><li><p>擦地的时候没有经过半脚掌</p></li><li><p>主力腿的转开和伸直的力量太少</p></li></ul><p>2.自从上了pbt，屁股往里收，从跨根转开的感觉能找到了，缺点是不能一直保持，当把注意力放在脚上的时候，还是会忘记屁股使劲，主力腿转开</p><p>3.现在复杂的组合也能记住了，随着练习次数的增多，记组合的能力也变强了</p><h4 id="Passe"><a href="#Passe" class="headerlink" title="Passe"></a>Passe</h4><p>1.吸起来的速度一定要快，一步到位；同时手的动作也要快</p><p>2.吸起来的时候，主力腿主动转开，同时腰也要拔起来，这次这两个动作有进步，整个passe感觉更稳，整个人也更舒展挺拔了</p><h4 id="Jete"><a href="#Jete" class="headerlink" title="Jete"></a>Jete</h4><p>1.jete一定要经过擦地出去，不能直接踢出去</p><p>2.jete一定要有力量，一步到位，高度为25度</p><h4 id="Fondu"><a href="#Fondu" class="headerlink" title="Fondu"></a>Fondu</h4><p>1.蹲的时候膝盖要留住，动力腿主动往回收，动力腿要有力量</p><p>2.今天加的新动作，主力腿在半脚尖上，直腿落脚后跟的时候，动力腿应该往上，形成对抗的力量</p><h4 id="en-Dehors"><a href="#en-Dehors" class="headerlink" title="en Dehors"></a>en Dehors</h4><p>空中划的时候，首先主力腿伸直，动力腿，从旁到后，保持转开，用脚尖划</p><h4 id="en-Dedans"><a href="#en-Dedans" class="headerlink" title="en Dedans"></a>en Dedans</h4><p>从旁到前，主力腿伸直，主力腿往下踩，左腰向上，身体不要向后躺，力量不要都集中在动力腿上</p><h3 id="pbt"><a href="#pbt" class="headerlink" title="pbt"></a>pbt</h3><p>1.用力绷脚的时候，感受到一点力量延伸释放出去的感觉，惊喜！</p><p>2.腹背肌力量好差，周内不上课，尽量用健身弥补吧</p><p>3.瑜伽球上的五位简直人间地狱，多找找下面那条腿内侧往里夹的感觉吧，希望下次可以控制住不从球上翻下来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;芭蕾基训&quot;&gt;&lt;a href=&quot;#芭蕾基训&quot; class=&quot;headerlink&quot; title=&quot;芭蕾基训&quot;&gt;&lt;/a&gt;芭蕾基训&lt;/h3&gt;&lt;h4 id=&quot;Pile&quot;&gt;&lt;a href=&quot;#Pile&quot; class=&quot;headerlink&quot; title=&quot;Pile&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>Go语言变量和常量</title>
    <link href="https://liupei.link/2022/08/09/Go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
    <id>https://liupei.link/2022/08/09/Go语言变量和常量/</id>
    <published>2022-08-09T15:44:08.000Z</published>
    <updated>2022-08-24T14:49:47.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-静态语言和动态语言在变量处理上的区别"><a href="#1-静态语言和动态语言在变量处理上的区别" class="headerlink" title="1.静态语言和动态语言在变量处理上的区别"></a>1.静态语言和动态语言在变量处理上的区别</h3><p>1.1 什么是变量的声明</p><p>为了方便对内存的操作，编程语言中，将一个名字</p><p>1.2 静态语言和动态语言在变量处理上的区</p><p>静态语言：在变量声明的时候，必须说明</p><p>动态语言：</p><h3 id="2-Go变量的声明和赋值"><a href="#2-Go变量的声明和赋值" class="headerlink" title="2.Go变量的声明和赋值"></a>2.Go变量的声明和赋值</h3><h4 id="2-1-变量的声明"><a href="#2-1-变量的声明" class="headerlink" title="2.1 变量的声明"></a>2.1 变量的声明</h4><ul><li><p>var语句用于声明变量/变量列表，类型放在最后</p></li><li><p>var语句可以出现在包或函数级别</p></li><li><p>可以一次声明多个变量</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, jython, java <span class="keyword">bool</span> <span class="comment">//出现在包级别，一次声明多个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">//出现在函数级别</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(i, c, python, java) <span class="comment">//输出是0 false false false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-变量的赋值"><a href="#2-2-变量的赋值" class="headerlink" title="2.2 变量的赋值"></a>2.2 变量的赋值</h4><h5 id="2-2-1-变量的初始化"><a href="#2-2-1-变量的初始化" class="headerlink" title="2.2.1 变量的初始化"></a>2.2.1 变量的初始化</h5><ul><li><p>在定义变量的时候声明变量的类型并且给变量赋值</p></li><li><p>变量的值如果是默认类型，在进行变量赋值的时候也可以省略类型</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在定义变量的时候声明变量的类型并且给变量赋值</span></span><br><span class="line"></span><br><span class="line">Var a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go有类型推断能力，如果使用默认类型（数值型、字符型、布尔型、字符串）的话，可以在声明变量的时候把类型删掉</span></span><br><span class="line"></span><br><span class="line">Var（</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">）</span><br></pre></td></tr></table></figure><h5 id="2-2-2-可以同时对多个变量进行初始化"><a href="#2-2-2-可以同时对多个变量进行初始化" class="headerlink" title="2.2.2 可以同时对多个变量进行初始化"></a>2.2.2 可以同时对多个变量进行初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时声明多个变量可以进行简写</span></span><br><span class="line"></span><br><span class="line">Var a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">Var b <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上两行可以简写为</span></span><br><span class="line"></span><br><span class="line">Var（</span><br><span class="line">    a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    b <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line">）</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="2-2-3-可以先给变量声明，再赋值"><a href="#2-2-3-可以先给变量声明，再赋值" class="headerlink" title="2.2.3 可以先给变量声明，再赋值"></a>2.2.3 可以先给变量声明，再赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明变量的类型，后给变量赋值</span></span><br><span class="line"></span><br><span class="line">Var a <span class="keyword">int</span> <span class="comment">//注意，在声明变量a的时候，类型放在最后</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-2-4-短变量声明"><a href="#2-2-4-短变量声明" class="headerlink" title="2.2.4 短变量声明"></a>2.2.4 短变量声明</h5><p>定义：在变量初始化时省略变量的类型，由系统自行判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b :=<span class="number">50</span> ,<span class="string">"abc"</span>  <span class="comment">//a和b的类型（int，string）由系统自行判断</span></span><br></pre></td></tr></table></figure><p>这种声明方式只能用在函数体内，不可以用于全局变量的声明和赋值</p><p>在相同的代码块中，不可以对同一个名称的变量进行再次初始化声明；但是可以对一个已经初始化声明的变量进行再次赋值</p><h5 id="2-2-5-交换两个变量的值"><a href="#2-2-5-交换两个变量的值" class="headerlink" title="2.2.5 交换两个变量的值"></a>2.2.5 交换两个变量的值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b=b,a</span><br></pre></td></tr></table></figure><h5 id="2-2-6-零值（没有明确初始值的变量会被赋予-零值）"><a href="#2-2-6-零值（没有明确初始值的变量会被赋予-零值）" class="headerlink" title="2.2.6 零值（没有明确初始值的变量会被赋予 零值）"></a>2.2.6 零值（没有明确初始值的变量会被赋予 零值）</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数值类型为 <span class="number">0</span>，</span><br><span class="line"></span><br><span class="line">布尔类型为 <span class="literal">false</span>，</span><br><span class="line"></span><br><span class="line">字符串为 <span class="string">""</span>（空字符串），判断字符串的为空时，判断字符串是否等于 <span class="string">""</span>  而不是判断字符串是否等于<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">float :<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">pointer, function, <span class="keyword">interface</span>, slice, channel, <span class="keyword">map</span>:<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">复合类型: <span class="keyword">go</span>语言会自动递归地将每一个元素初始化为其类型对应的零值。比如：数组， 结构体 。</span><br></pre></td></tr></table></figure><p>说明：风格尽量简单一致，因此后续可能有一部分功能可能会被禁用</p><h4 id="2-3-变量的声明和其它语言的差异"><a href="#2-3-变量的声明和其它语言的差异" class="headerlink" title="2.3 变量的声明和其它语言的差异"></a>2.3 变量的声明和其它语言的差异</h4><p>go是一种强类型语言</p><ul><li><p>赋值可以进行自动类型判断</p></li><li><p>在一个赋值语句中可以对多个变量同时进行赋值</p></li></ul><h3 id="3-常量的定义"><a href="#3-常量的定义" class="headerlink" title="3.常量的定义"></a>3.常量的定义</h3><p>常量的声明与变量类似，只不过是使用 const 关键字</p><p>常量可以是字符、字符串、布尔值或数值</p><p>常量不能用 := 语法声明</p><p>数值常量：一个未指定类型的常量由上下文来决定它的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连续的变量赋值</span></span><br><span class="line"></span><br><span class="line">Const(</span><br><span class="line">    Monday = <span class="literal">iota</span> + <span class="number">1</span> <span class="comment">//代表后面的变量依次在iota的基础上加1</span></span><br><span class="line">    Tuesday  <span class="comment">//tuesday会被自动赋值为2</span></span><br><span class="line">    Wednesday  <span class="comment">//wednes会被自动赋值为3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连续的位运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Open = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">//代表后面的变量依次在iota的基础上左移一位</span></span><br><span class="line">    <span class="built_in">close</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>补充：iot从常量结构的第一行（不包含注释和空行）开始，从0逐行加1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-静态语言和动态语言在变量处理上的区别&quot;&gt;&lt;a href=&quot;#1-静态语言和动态语言在变量处理上的区别&quot; class=&quot;headerlink&quot; title=&quot;1.静态语言和动态语言在变量处理上的区别&quot;&gt;&lt;/a&gt;1.静态语言和动态语言在变量处理上的区别&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://liupei.link/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>DemiPile</title>
    <link href="https://liupei.link/2022/08/08/DemiPile/"/>
    <id>https://liupei.link/2022/08/08/DemiPile/</id>
    <published>2022-08-08T14:02:05.000Z</published>
    <updated>2022-08-09T14:36:50.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Demi-Pile动作要点"><a href="#Demi-Pile动作要点" class="headerlink" title="Demi Pile动作要点"></a>Demi Pile动作要点</h3><h4 id="1-腿部肌肉在pile中如何运用"><a href="#1-腿部肌肉在pile中如何运用" class="headerlink" title="1.腿部肌肉在pile中如何运用"></a>1.腿部肌肉在pile中如何运用</h4><p>要点：大腿的肌肉要持续的不断的发力，把力量往上延伸到尽头</p><p>大腿力量往上使到尽头了的表现：</p><ul><li><p>大腿从视觉上看起来更细</p></li><li><p>大腿的肌肉到膝盖之间有一定距离</p></li><li><p>大腿的内侧肌肉也要使劲，摸一下，如果大腿肌肉是可以晃动的，说明还不够使劲</p></li><li><p>如果力量没有使到头，在地面上做动作的时候，膝盖离地面是有一定空隙的，是没有完全紧贴地面的</p></li><li><p>如果大腿力量没有向上使到头，抬腿的时候，膝盖也是弯的；</p></li></ul><h4 id="2-脚部肌肉在pile中如何使用"><a href="#2-脚部肌肉在pile中如何使用" class="headerlink" title="2.脚部肌肉在pile中如何使用"></a>2.脚部肌肉在pile中如何使用</h4><p>要点：脚指头平铺在地面上，感觉脚使劲往下踩，脚趾头牢牢的抓住地面</p><p>脚往下使劲的表现：</p><p>站在地上的时候可以看到脚踝前面的部分有一根筋凸显出来，如果没有一根筋凸显出来，说明站的不够使劲，同时做的整个过程中，这根筋也不能放松，这样可以增加脚腕子的稳定性</p><h4 id="3-如何做出有质感的Demi-pile"><a href="#3-如何做出有质感的Demi-pile" class="headerlink" title="3.如何做出有质感的Demi pile"></a>3.如何做出有质感的Demi pile</h4><p>要点：往下蹲的时候，要往上提着做；往下之前，头顶找天花板，腿部肌肉往上提，大腿内侧也要使劲；往下的时候有控制的往下</p><p>起来之后，再使劲一下，再往上收紧一下，再往下进行下一次的蹲</p><p>错误做法：直接整个人往下蹲，没有往上提着向下蹲；蹲下去的时候，整个大腿是软的</p><h4 id="4-肌肉保持外开"><a href="#4-肌肉保持外开" class="headerlink" title="4.肌肉保持外开"></a>4.肌肉保持外开</h4><p>要点：屁股收紧，从跨根转开，保证不倒脚的前提（不要倒脚，足弓离地面有距离，距离越高越好），控制小腿往前转（从前面看，可以看到更多的小腿肌肉），膝盖冲脚尖的方向</p><p>错误的做法：只是脚尖冲旁，膝盖和小腿完全冲前</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Demi-Pile动作要点&quot;&gt;&lt;a href=&quot;#Demi-Pile动作要点&quot; class=&quot;headerlink&quot; title=&quot;Demi Pile动作要点&quot;&gt;&lt;/a&gt;Demi Pile动作要点&lt;/h3&gt;&lt;h4 id=&quot;1-腿部肌肉在pile中如何运用&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="芭蕾" scheme="https://liupei.link/tags/%E8%8A%AD%E8%95%BE/"/>
    
  </entry>
  
  <entry>
    <title>2021，保持热爱</title>
    <link href="https://liupei.link/2021/01/07/2021%EF%BC%8C%E4%BF%9D%E6%8C%81%E7%83%AD%E7%88%B1/"/>
    <id>https://liupei.link/2021/01/07/2021，保持热爱/</id>
    <published>2021-01-07T14:27:04.000Z</published>
    <updated>2021-09-26T14:06:40.457Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、我的美好生活"><a href="#一、我的美好生活" class="headerlink" title="一、我的美好生活"></a><strong>一、我的美好生活</strong></h2><h5 id="1-美好的一天从早餐开始"><a href="#1-美好的一天从早餐开始" class="headerlink" title="1.美好的一天从早餐开始"></a><strong>1.美好的一天从早餐开始</strong></h5><p>自从搬家之后，离公司更近了，每天可以早起做做早餐，每天吃自己做的早餐，感觉工作起来都很有劲，其实之前住蓝堡公寓的时候也想过，但因为住得远，另外也觉得住公寓总像个宿舍，所以自己做早餐这件事也一直没有落实，看来住得离工作的地方近还是很有好处的，以后尽量也要选择一个离家近的公司～</p><p>记录一下我的早餐菜单</p><ul><li><p>酸奶吐司：做起来非常简单方便，重点是烤的时候房间里都是面包香味，闻起来就非常满足</p></li><li><p>火腿鸡蛋卷饼：六月香豆瓣酱+老碗会的油泼辣子拌起来，真的有路边煎饼果子的味道</p></li><li><p>烤红薯：一定要买蜜薯，蒸45min，冬天里，房间里充满烤红薯的香味，真的能让我心情大好</p></li><li><p>鸡蛋羹：一定要放鱼豉油，但是我蒸出来的鸡蛋羹是个马蜂窝，还是再多琢磨琢磨</p></li><li><p>煮玉米：感觉深圳买的玉米总是煮不出玉米的香味，好失望</p></li><li><p>蒸芋头：蒸芋头可以蘸什么酱料呢？没有蘸料好难吃</p></li></ul><p>新的一年，希望我也能保持做早餐的习惯，美好的一天从美味的早餐开始～并且要多开发一些好吃的早餐😋</p><h5 id="2-美好的周末从少叫外卖开始"><a href="#2-美好的周末从少叫外卖开始" class="headerlink" title="2.美好的周末从少叫外卖开始"></a><strong>2.美好的周末从少叫外卖开始</strong></h5><p>发现周末自己安安静静地做一顿饭，除了吃自己做的饭比较满足之外，更加享受和治愈的是做饭的过程，安安静静的，脑子里可以随意想点东西，没有具体的想某一件事情，真的有种岁月静好的感觉，2020年已经学会了包子、饺子、糖饼、煎饼、手擀面、麻食、鱼香肉丝、宫保鸡丁、土豆炖鸡肉，希望2021再多学会几个菜</p><h5 id="3-学会做减法"><a href="#3-学会做减法" class="headerlink" title="3.学会做减法"></a><strong>3.学会做减法</strong></h5><p>今天搬了一次家，在蓝堡住了也有两年多了，搬家的时候发现真的有挺多东西的，很多不用的基本都扔掉或者送给同事了，搬到新家感觉很轻松，以后也要养成定期给家里做减法的习惯</p><h2 id="二、终生运动"><a href="#二、终生运动" class="headerlink" title="二、终生运动"></a><strong>二、终生运动</strong></h2><p>前两天在公司内部报名了一节《复盘方法论》的课程，其中讲师讲到了他通过参加一个减脂训练营达到了减肥的目的之后，一直坚持运动，并且发现了运动的诸多好处，比如自己坚持运动后身材越来越好、基本也不怎么生病了，老师也重点情调了，运动这件事情是终生，我听了之后特别认同这件事情。我也发现了运动的很多好处，不生病、会变瘦这些我到没感受太多，重点是感觉运动很开心，能让我的身体保持一个良好的状态去工作、学习、玩耍。在2020年的最后一个月，我也终于从旱鸭子，变成了水中小🐢，希望自己2021年继续坚持芭蕾、坚持游泳，游出牛奶水光肌！</p><h2 id="三、努力工作"><a href="#三、努力工作" class="headerlink" title="三、努力工作"></a><strong>三、努力工作</strong></h2><p>2020年感觉对工作的投入还不够多，重点是业余没有将太多的时间投入在工作上面，这一点在今年要重点反思并改进一下。近几天又听到了一则刚毕业没多久的学生在下班路上猝死的新闻，我认为，从我现在的工作情况来讲，如果多提高一点自己的工作效率，还是大部分时间都可以做到不加班的，所以不要闷头一直干工作，多想办法提升效率，也就没有那么多加班啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、我的美好生活&quot;&gt;&lt;a href=&quot;#一、我的美好生活&quot; class=&quot;headerlink&quot; title=&quot;一、我的美好生活&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、我的美好生活&lt;/strong&gt;&lt;/h2&gt;&lt;h5 id=&quot;1-美好的一天从早餐开
      
    
    </summary>
    
    
      <category term="总结" scheme="https://liupei.link/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>蛙泳笔记</title>
    <link href="https://liupei.link/2020/12/27/%E8%9B%99%E6%B3%B3%E7%AC%94%E8%AE%B0/"/>
    <id>https://liupei.link/2020/12/27/蛙泳笔记/</id>
    <published>2020-12-27T11:36:41.000Z</published>
    <updated>2020-12-27T15:10:38.677Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、蛙泳"><a href="#一、蛙泳" class="headerlink" title="一、蛙泳"></a><strong>一、蛙泳</strong></h2><h5 id="1-憋气换气"><a href="#1-憋气换气" class="headerlink" title="1.憋气换气"></a><strong>1.憋气换气</strong></h5><p>手抓住池边，用嘴巴吸一大口气存在胸腔，然后将头埋在水中，注意头埋下去的时候不要埋的太浅，尽量让水没过耳朵；然后在水中大概停3～5秒左右，嘴巴开始在水中吐气，吐气整个过程包括出水面吐一半左右就可以，不要全部吐光（全部吐光身体会下沉，下沉的太多，头就抬不起来了）；然后再用嘴巴吸气，重复以上动作</p><p>注意点：</p><ul><li><p>假如头埋到水里的时候不小心吸进了水，也不要紧张，头出水面的时候，把吸进去的水吐出去就好了</p></li><li><p>头埋下去的时候，由于水的浮力，身体会不由自主的漂起来，这个时候腿部可以用一点力量站稳就可以了</p></li></ul><h5 id="2-漂浮"><a href="#2-漂浮" class="headerlink" title="2.漂浮"></a><strong>2.漂浮</strong></h5><p>憋气换气练习没问题后，就可以练习漂浮了；手抓住池边，吸气低头，将头埋在水中，身体放轻松，让身体自然的漂起来就好</p><p>注意点：</p><ul><li>身体漂起来的时候，手臂要伸直，不要屈肘；这个时候屈肘容易养成不好的习惯，如果这时候屈肘，后面练习蛙泳手的时候也容易屈肘</li></ul><h5 id="3-蛙泳腿练习"><a href="#3-蛙泳腿练习" class="headerlink" title="3.蛙泳腿练习"></a><strong>3.蛙泳腿练习</strong></h5><p>蛙泳腿六字口诀“慢收翻、快蹬夹”，口诀说起来很简单，做标准不容易</p><p>收：慢收，收的时候，大腿不要太往下沉（也就是上身和大腿的角度是钝角，不要收大腿收很多，都呈90度了），只需要把小腿收起来，一定要收紧，脚后跟要尽量贴近屁股；</p><p>翻：收的动作做好之后，脚丫子要勾脚往外翻（也就是脚指头的方向朝外，脚后跟的方向朝内），这里一定要勾脚、勾脚、勾脚（芭蕾一直强调绷脚、绷脚、绷脚，蛙泳腿强调勾脚、勾脚、勾脚，我的脚太难了，所以第一节课，我的脚总是勾不住），做好收翻的动作之后，从后面看，腿部是呈一个W的形状</p><p>蹬夹：蹬夹要合起来做，整个过程要快、快、快，并且要用力蹬夹（我是软绵绵，不知道我的饭吃到哪里去了，芭蕾的肌肉训练训到哪里去了），蹬的过程中注意也要勾脚</p><h5 id="4-蛙泳手练习"><a href="#4-蛙泳手练习" class="headerlink" title="4.蛙泳手练习"></a><strong>4.蛙泳手练习</strong></h5><p>蛙泳手分解动作有4步</p><p>1.身体漂平后（此时，手是双手合十，直臂向前的），双手掌心朝外划开，这里划的距离不要太大，略宽于肩膀即可；</p><p>2.手划开后屈肘抱水，抱水的时候，只是屈肘，大臂不需要做什么动作，小臂折叠，并且掌心要朝自己的身体，手背和小臂是呈一条直线的；</p><p>3.抱水完成后，双手经过自己的胸部两侧合十，注意是胸部两侧，不是胃两侧</p><p>4.双手合十后，双臂伸直，注意这里一定要伸直，不要屈肘</p><p>以上4步熟悉之后，就可以连起来做快一点了，一做快就什么要点都忘了，最容易出问题的就是抱水的时候，手掌心没有朝向自己的身体，幸好我是女孩子，还能尽量保证双手合十的时候，是经过胸部两侧的；</p><h5 id="5-完整蛙泳动作配合练习"><a href="#5-完整蛙泳动作配合练习" class="headerlink" title="5.完整蛙泳动作配合练习"></a><strong>5.完整蛙泳动作配合练习</strong></h5><p>身体漂平之后，开始在水中吐气，头抬起来后，手开始做划水抱水动作（这个动作要用点力气，尽可能把自己的身体撑起来，保证头能抬起来吸到气），同时张嘴吸气，手到胸部两侧准备合十的时候，开始慢收腿，同时将头埋入水中，然后双臂伸直，伸直之后，再开始蹬夹腿</p><h2 id="二、反蛙泳"><a href="#二、反蛙泳" class="headerlink" title="二、反蛙泳"></a><strong>二、反蛙泳</strong></h2><p>准备：吸气，身体平躺在水面上，脖子放松，头微微后仰，漂平后就可以开始做动作了</p><p>腿部动作：腿部动作和蛙泳腿一样，只是要注意这里收腿的时候要收紧（膝盖可以略微高出水面），这样蹬腿的时候就是向后蹬，而不是向下蹬，注意蹬腿的时候要勾脚</p><p>手部动作：手臂张开（手臂要伸直，不要屈肘），手掌往下压然后往后推（这里的后指的是前进方向的反方向），手部动作和腿部动作是同步的</p><h2 id="三、抬头蛙"><a href="#三、抬头蛙" class="headerlink" title="三、抬头蛙"></a><strong>三、抬头蛙</strong></h2><p>腿部动作和蛙泳是一样的，手部动作有点不一样，抬头蛙手部划水的时候，要张臂划开（这里的开度比蛙泳的划水开度要大，不只是略宽于肩膀就可以的），划到身体两侧，然后做抱水，双手合十，双臂伸直的动作即可</p><p>关于抬头蛙换气：换气的时机是在双臂张到最大的时候开始吸气，因为这个时候身体会被双臂撑起来，保证能吸到气</p><h2 id="四、踩水"><a href="#四、踩水" class="headerlink" title="四、踩水"></a><strong>四、踩水</strong></h2><p>手部动作：手臂微微弯曲，不要弯曲的太多，手指并拢，做压水动作</p><p>腿部动作：腿部动作和蛙泳腿类似，只是幅度比蛙泳腿的要小一点，也不需要夹水，收腿的时候，尽量收紧一点，并且要勾脚，蹬腿的时候不要只做后侧的蹬腿，要向前蹬一点（感觉是脚丫子在水中逆时针划了一个圈）；蹬腿完之后不需要“夹”，也就是双腿不需要并拢，再收腿做下一次动作即可</p><p>头部：头部一直保持在水面上，如果要吸气，是在双手压水（可以撑起来一点身体）的时候吸气</p><p>身体：身体可以微微前倾，保持身体平衡</p><h2 id="五、一点感悟"><a href="#五、一点感悟" class="headerlink" title="五、一点感悟"></a><strong>五、一点感悟</strong></h2><p>1.前期动作一定要做标准，不要着急，动作做不标准的前提下，即使呼哧呼哧一直加快动作，也不会有什么提升，反而会越做越错，尽量让自己放轻松，慢下来，想清楚动作并把动作的完成度做到极致</p><p>2.站在干岸上动作练的再好，想得再清楚，不在水里练还是白瞎，所以一定要多练多练，才能有进步；当然，练的过程也要多琢磨琢磨自己的动作，领悟正确的泳姿最重要</p><p>3.完整配合的时候，可能会有点慌乱，这个动作没做对，那个动作也不达标；但是不要想着一次性把所有错误都纠正过来，心急吃不了热豆腐，一次只注意纠正一个动作就好，慢慢练习就可以把错误都纠正过来了</p><p>4.多看自己游泳的视频，能很直观的感受的自己的错误在哪，所以后续练习也可以让小伙伴们拍拍视频，自己多琢磨琢磨</p><p>5.沟通很重要，有问题要及时和教练沟通，当然前提是自己要有思考，只有把自己的疑惑都解决了，才能进步得更快</p><p>6.游泳真是一项能让人很快乐的运动，不会有汗流浃背，身上黏糊糊感觉，如果我游得再美一点，游泳就快超过芭蕾在我心目中的地位了</p><p>7.泳池中的小朋友也很可爱，今天上最后一节课时，遇到一个小男孩，说我和他的爸爸一样高，要和我比憋气，还要和我比谁游得快，还给我教在深水区怎么自救的办法，哈哈哈，后来我换了一个泳道，他横穿泳道要来我这边和我一起玩，结果被救生员警告了一下，被他妈妈喊回去了～～和小孩子一起玩真是一件幸福的事情呐😊</p><p>最后记录下自己最后一节课的速度：50m，2分15秒，希望3个月后可以游进2分钟内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、蛙泳&quot;&gt;&lt;a href=&quot;#一、蛙泳&quot; class=&quot;headerlink&quot; title=&quot;一、蛙泳&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、蛙泳&lt;/strong&gt;&lt;/h2&gt;&lt;h5 id=&quot;1-憋气换气&quot;&gt;&lt;a href=&quot;#1-憋气换气&quot; c
      
    
    </summary>
    
    
      <category term="健身" scheme="https://liupei.link/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>晒太阳</title>
    <link href="https://liupei.link/2020/12/19/%E6%99%92%E5%A4%AA%E9%98%B3/"/>
    <id>https://liupei.link/2020/12/19/晒太阳/</id>
    <published>2020-12-19T15:33:08.000Z</published>
    <updated>2020-12-27T15:19:35.876Z</updated>
    
    <content type="html"><![CDATA[<p>南方的冬天真的是起床困难，昨天早上闹钟响起，顺手关了闹钟，早餐又想吃烤红薯了，不能赖床了，可是被窝真的好暖，外面很冷，先伸出一个脚丫子，好冷，再伸出一条胳膊，还是好冷，索性一把掀开被子，麻溜穿上毛绒绒的睡衣，成功起床。</p><p>拉开窗帘，阳光照了进来，感觉好久没有出太阳了，真庆幸今天没赖床，不然阳光要悄悄从阳台溜走了。洗好红薯放进烤箱，坐在沙发上，阳光刚好照在我身上，不一会，烤箱散发出烤红薯的香味，我感到十分温暖、平静。想起以前上学，每次到冬天，课间休息的时候，大家在教室外面站一排排晒太阳，可惜课间时间太短，晒不够，上课铃声响起，大家都要不情不愿的走进冷冰冰的教室。不知道以前一起晒太阳的同学们现在都怎么样了，不知道大家在冬天晒到暖暖的太阳的时候是不是也会想起以前上学时和同学们一起晒太阳的时光～</p><p>顾城说：</p><p>我多么希望，有一个门口 </p><p>早晨，阳光照在草上</p><p>我们站着</p><p>扶着自己的门扇</p><p>门很低，但太阳是明亮的</p><p>草在结它的种子</p><p>风在摇它的叶子</p><p>我们站着，不说话</p><p>就十分美好</p><p><br></p><p>我也希望：</p><p>有一个冬日的早晨</p><p>阳光暖暖的</p><p>我们静静地坐着</p><p>晒着太阳</p><p>就十分美好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;南方的冬天真的是起床困难，昨天早上闹钟响起，顺手关了闹钟，早餐又想吃烤红薯了，不能赖床了，可是被窝真的好暖，外面很冷，先伸出一个脚丫子，好冷，再伸出一条胳膊，还是好冷，索性一把掀开被子，麻溜穿上毛绒绒的睡衣，成功起床。&lt;/p&gt;
&lt;p&gt;拉开窗帘，阳光照了进来，感觉好久没有出太
      
    
    </summary>
    
    
      <category term="说说" scheme="https://liupei.link/tags/%E8%AF%B4%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>时间管理</title>
    <link href="https://liupei.link/2020/12/19/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>https://liupei.link/2020/12/19/时间管理/</id>
    <published>2020-12-19T13:10:13.000Z</published>
    <updated>2020-12-27T15:19:12.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>时间管理，对外管理事务、管理合作关系，对内管理自己；时间管理的本质是“提高工作效率”。</p><h4 id="一、做好计划"><a href="#一、做好计划" class="headerlink" title="一、做好计划"></a><strong>一、做好计划</strong></h4><h5 id="1-计划的两个基本功能"><a href="#1-计划的两个基本功能" class="headerlink" title="1.计划的两个基本功能"></a><strong>1.计划的两个基本功能</strong></h5><ul><li>规划：制定出实现目标的有效路径</li><li>备忘：执行时方向清晰、全情投入</li></ul><p>计划不仅是要在头脑中构思，还要将计划可视化，也就是将计划落实在纸面上</p><h5 id="2-极简的项目管理表：从事情出发，规划行动步骤，分析项目并制定截止日期"><a href="#2-极简的项目管理表：从事情出发，规划行动步骤，分析项目并制定截止日期" class="headerlink" title="2.极简的项目管理表：从事情出发，规划行动步骤，分析项目并制定截止日期"></a><strong>2.极简的项目管理表：从事情出发，规划行动步骤，分析项目并制定截止日期</strong></h5><ul><li>按项目的工作内容属性拆分</li><li>按项目的阶段属性拆分</li></ul><p>注意点：</p><ul><li>不要把工作和时间点拆得过细，时间颗粒度一般是计划周期的下两级（比如计划周期是季度，那时间颗粒度拆分到星期比较合适）</li><li>项目分拆不重不漏（MECE原则）</li><li>分拆颗粒度责任到人</li><li>设置截止日期</li><li>识别关系人，给关系人设置截止日期，并设置进度表</li></ul><h5 id="3-日历表：从时间维度锁定重要的事情"><a href="#3-日历表：从时间维度锁定重要的事情" class="headerlink" title="3.日历表：从时间维度锁定重要的事情"></a><strong>3.日历表：从时间维度锁定重要的事情</strong></h5><p>（1）重要的事情先安排，如果识别重要的事情呢？</p><ul><li>短期可以完成的，对工作结果有影响的</li><li>短期对工作无明显帮助，但一旦完成，有巨大红利的</li></ul><p>（2）好的计划是有一定余地和缓冲的，留20%的缓冲地带</p><h4 id="二、把时间变成产出"><a href="#二、把时间变成产出" class="headerlink" title="二、把时间变成产出"></a><strong>二、把时间变成产出</strong></h4><h5 id="1-工作推进的5个原则"><a href="#1-工作推进的5个原则" class="headerlink" title="1.工作推进的5个原则"></a><strong>1.工作推进的5个原则</strong></h5><ul><li>确保不中断的时间段：很多工作一旦中断，再重新开始就需要花费很多的时间和精力</li><li>当下主义和应急措施：工作要在发生的当下处理完，当工作被打断时要有一定的应急措施，比如将当下没有处理完的文件放在一个固定的文件夹中，以便过一段时间重启时能对接得上</li><li>以拙速为宗旨：不要太过追求完美，先完成一定阶段的任务。如果有时间，再进一步完善就好</li><li>偶尔休息：放松放松，再回过头来那些棘手的问题，说不定就有新的思路了</li><li>先做不确定的事情：前提是手头事情的优先级都一样，比如去比较远的地方参加聚会，就应该到了目的地之后再吃饭，而不是吃完饭之后再出门。如果中途遇到交通堵塞，我们可以不吃饭；如果到达的时间比预定的时间早，我们就可以不慌不忙地吃饭</li></ul><h5 id="2-解决“拖延症“，将复杂任务拆分成简单动作的4字口诀"><a href="#2-解决“拖延症“，将复杂任务拆分成简单动作的4字口诀" class="headerlink" title="2.解决“拖延症“，将复杂任务拆分成简单动作的4字口诀"></a><strong>2.解决“拖延症“，将复杂任务拆分成简单动作的4字口诀</strong></h5><ul><li>转：可以授权给别人的，不应该由自己处理的事情，转出去</li><li>做：一个工作只有2~3min时间就可以完成，马上去做，不要让这些小的事情占大脑内存</li><li>存：暂时不做的，优先级较低的，先放入代办清单</li><li>扔：不做的事情，从代办中移除，不要让大脑被琐事占据</li></ul><h4 id="三、敏捷工作法"><a href="#三、敏捷工作法" class="headerlink" title="三、敏捷工作法"></a><strong>三、敏捷工作法</strong></h4><h5 id="1-四个时间管理算法"><a href="#1-四个时间管理算法" class="headerlink" title="1.四个时间管理算法"></a><strong>1.四个时间管理算法</strong></h5><ul><li><p>最近截止时间算法：如果每个任务都是有截止日期的，按照截止日期的先后顺序来完成</p></li><li><p>摩尔算法：当你手头有很多任务，每个任务又都有自己的截止时间，如果很明确在截止日期前完不成所有的任务，那就要尽可能多的完成任务，即放弃占用时间最长的任务</p></li><li><p>小事优先原则：都不是急事的前提下，小事优先</p></li><li><p>加权最短时间处理算法：每个任务都有截止时间，每个任务的重要程度都不一样，密度高者优先</p></li></ul><p>任务密度=任务的重要程度/完成时间</p><p>这是一种量化思想，用自己的标准给任务设值</p><h5 id="2-快速工作法：一种不断迭代的工作方式（最小可交付、持续迭代）"><a href="#2-快速工作法：一种不断迭代的工作方式（最小可交付、持续迭代）" class="headerlink" title="2.快速工作法：一种不断迭代的工作方式（最小可交付、持续迭代）"></a><strong>2.快速工作法：一种不断迭代的工作方式（最小可交付、持续迭代）</strong></h5><ul><li><p>建立交付意识：输入—&gt;处理—&gt;交付</p></li><li><p>计划交付节点：前紧后松</p></li><li><p>多个项目并行：重要的事情多迭代，紧急的事情先迭代</p></li><li><p>不主张同时做多件事</p></li></ul><h4 id="四、学会与忙碌相处"><a href="#四、学会与忙碌相处" class="headerlink" title="四、学会与忙碌相处"></a><strong>四、学会与忙碌相处</strong></h4><p>忙碌的人，行动力和执行力越强，忙碌是一种自驱模式，带来成就感和满足感</p><p>三个建议：</p><p>1.找到处于自己的目标：发自内心喜欢的，内心想要的“胜利目标”，给自己带来大的动力</p><ul><li>挑战舒适区</li><li>开创新领域</li></ul><p>2.给成长留出足够的投入：建议一年至少留出200h，用户锻炼和能力提升，在学习上敢于投入金钱，投入让自己心疼的钱，获取能带来意想不到的提升</p><p>3.跑出一个小循环，制造机会让自己尝到甜头</p><p>4.自我驱动：把自己学到的某个技能可以立刻运用到工作中，“现学现卖”，找到最小的一个尝试机会，自己想要什么是逐渐试出来的</p><h4 id="五、管理合作者的时间"><a href="#五、管理合作者的时间" class="headerlink" title="五、管理合作者的时间"></a><strong>五、管理合作者的时间</strong></h4><h5 id="1-学会与人合作"><a href="#1-学会与人合作" class="headerlink" title="1.学会与人合作"></a><strong>1.学会与人合作</strong></h5><ul><li>开放透明：养成透明的工作习惯</li><li>互相负责：对上和对下的时间管理</li></ul><h5 id="2-三个透明的沟通习惯"><a href="#2-三个透明的沟通习惯" class="headerlink" title="2.三个透明的沟通习惯"></a><strong>2.三个透明的沟通习惯</strong></h5><ul><li>计划共享：在制定计划的时候就把大家拉进来，让大家有参与感</li><li>实时同步：主动推销自己的工作，帮助调度，协调资源</li><li>当前沟通</li></ul><h5 id="3-管理上级的时间"><a href="#3-管理上级的时间" class="headerlink" title="3.管理上级的时间"></a>3.<strong>管理上级的时间</strong></h5><ul><li>主动固定下来和上级一对一沟通的时间</li><li>利用项目管理表，定期和上级汇报项目、任务进度</li><li>汇报内容：工作重点、优先级排序、项目进展汇报、风险预警</li></ul><h5 id="4-管理自己和下属的时间"><a href="#4-管理自己和下属的时间" class="headerlink" title="4.管理自己和下属的时间"></a><strong>4.管理自己和下属的时间</strong></h5><p>充分授权给下属，人的成长是需要有具体的事情做载体的</p><p>参考：</p><p><a href="http://www.360doc.cn/mip/718855396.html" target="_blank" rel="noopener">http://www.360doc.cn/mip/718855396.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;时间管理，对外管理事务、管理合作关系，对内管理自己；时间管理的本质是“提高工作效率”。&lt;/p&gt;
&lt;h4 id=&quot;一、做好计划&quot;&gt;&lt;a href=&quot;#一、做好计划&quot; class=&quot;headerlink&quot; title=&quot;一、做好计划&quot;&gt;&lt;/a&gt;&lt;str
      
    
    </summary>
    
    
      <category term="效能提升" scheme="https://liupei.link/tags/%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
</feed>
